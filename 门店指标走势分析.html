
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é—¨åº—ä¸šåŠ¡æŒ‡æ ‡èµ°åŠ¿åˆ†æç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0/dist/chartjs-plugin-datalabels.min.js"></script>
        <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .store-selector {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .store-tabs {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .store-tab {
            padding: 10px 25px;
            border: none;
            background: white;
            color: #495057;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .store-tab:hover {
            background: #e9ecef;
        }

        .store-tab.active {
            background: white;
            color: #667eea;
            border-color: #667eea;
            border-bottom-color: white;
            position: relative;
            top: 2px;
        }

        .content {
            padding: 30px;
            background: white;
        }

        .charts-grid {
            display: flex;
            flex-direction: column;
            gap: 35px;
        }

        .chart-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
            margin-bottom: 30px;
            position: relative;
        }

        .chart-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
            border-color: #dee2e6;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .chart-container:hover::before {
            opacity: 0.1;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .chart-subtitle {
            font-size: 12px;
            color: #6c757d;
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }


        .legend-custom {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        /* å›¾è¡¨å¯¼èˆªæ ·å¼ - æ‚¬æµ®è§¦å‘ */
        .chart-navigation-trigger {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1001;
            transition: all 0.3s ease;
            color: white;
            font-size: 18px;
        }

        .chart-navigation-trigger:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .chart-navigation-trigger.active {
            background: #e74c3c;
        }

        .chart-navigation {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
            z-index: 1000;
            max-height: 70vh;
            overflow-y: auto;
            min-width: 150px;
            opacity: 0;
            visibility: hidden;
            transform: translateX(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .chart-navigation.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
            pointer-events: all;
        }

        .chart-navigation:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        /* å¯¼èˆªæ ‡é¢˜ */
        .navigation-header {
            user-select: none;
            margin-bottom: 10px;
            position: relative;
        }

        /* å“åº”å¼æ—¶éšè—å¯¼èˆª */
        @media (max-width: 1200px) {
            .chart-navigation-trigger {
                top: auto;
                bottom: 20px;
            }

            .chart-navigation {
                top: auto;
                bottom: 70px;
                max-height: 200px;
                max-width: 200px;
            }
        }

        @media (max-width: 768px) {
            .chart-navigation-trigger,
            .chart-navigation {
                display: none;
            }
        }

        .chart-navigation h4 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #2c3e50;
            font-weight: 600;
        }

        .nav-item {
            display: block;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            text-decoration: none;
            color: #495057;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-item:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: translateX(-2px);
        }

        .nav-item.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .nav-group {
            margin-bottom: 15px;
        }

        .nav-group-title {
            font-size: 11px;
            font-weight: bold;
            color: #6c757d;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .charts-grid {
                flex-direction: column;
            }

            .store-tabs {
                flex-wrap: wrap;
            }

                }
    /* è½¬åŒ–åˆ†æå›¾è¡¨æ ·å¼ */
        .chart-subsection {
            margin-bottom: 30px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        .chart-subsection::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
        }

        .subsection-title {
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            border-left: 3px solid #667eea;
        }

        .chart-wrapper-small {
            height: 350px;
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 1px 6px rgba(0,0,0,0.05);
            border: 1px solid #f1f3f5;
        }

        /* è½¬åŒ–ç‡å›¾è¡¨ç‰¹æ®Šé«˜åº¦ */
        .chart-wrapper-small.rate-chart {
            height: 300px;
        }

        .special-chart {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            padding: 28px;
            border-radius: 18px;
            border: 2px solid #e9ecef;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            position: relative;
            margin-bottom: 35px;
        }

        .special-chart::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 18px 18px 0 0;
        }

        /* å›¾ä¾‹æ ·å¼ä¼˜åŒ– */
        .chart-container .chartjs-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
            margin: 0;
            background: rgba(248, 249, 250, 0.8);
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .chart-container .chartjs-legend li {
            display: inline-flex;
            align-items: center;
            margin: 4px 8px;
            padding: 4px 8px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            font-weight: 500;
        }

        .chart-container .chartjs-legend li:hover {
            background: #f8f9fa;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .chart-container .chartjs-legend li.hidden {
            opacity: 0.4;
            background: #f8f9fa;
        }

        .chart-container .chartjs-legend li span {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 6px;
            border: 2px solid transparent;
        }

        /* æ‚¬æµ®ä¿¡æ¯æ¡†æ ·å¼ */
        .hover-info {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            z-index: 10000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            max-width: 250px;
            line-height: 1.4;
        }

        .hover-info .month {
            color: #4fc3f7;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .hover-info .data {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .hover-info .label {
            color: #b0bec5;
        }

        .hover-info .value {
            color: #ffffff;
            font-weight: bold;
        }
        /* å‚è€ƒçº¿ç®¡ç†è§¦å‘æŒ‰é’® */
        .reference-line-trigger {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: #9b59b6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            font-size: 16px;
        }

        .reference-line-trigger:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }

        /* å‚è€ƒçº¿é€‰æ‹©å™¨ */
        .reference-line-selector {
            position: fixed;
            top: 120px;
            right: 20px;
            width: 280px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            z-index: 1001;
            display: none;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }

        .reference-line-selector.show {
            display: block;
        }

        .selector-header {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .selector-header h5 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .reference-line-options {
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .reference-option {
            margin-bottom: 10px;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .reference-option:hover {
            border-color: #9b59b6;
            background: #f8f9fa;
        }

        .reference-option.active {
            border-color: #9b59b6;
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .reference-option-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .reference-option-value {
            font-size: 12px;
            opacity: 0.8;
        }

        .current-store-info {
            font-size: 14px;
            font-weight: bold;
            color: #6c757d;
            text-align: center;
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .indicator-section {
            margin-bottom: 15px;
        }

        .indicator-title {
            font-weight: 600;
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e9ecef;
        }

        .reference-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .reference-option-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .reference-option-item:hover {
            border-color: #9b59b6;
            background: #f8f9fa;
            transform: translateY(-1px);
        }

        .reference-option-item.active {
            border-color: #9b59b6;
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .reference-option-item.active .reference-option-name,
        .reference-option-item.active .reference-option-value {
            color: white;
        }

        .reference-option-item.active .indicator-title {
            color: rgba(255, 255, 255, 0.8);
        }

        .reference-option-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        .reference-option-info {
            flex: 1;
            min-width: 0;
        }

        /* å‚è€ƒçº¿ç®¡ç†å¼¹çª— */
        .reference-line-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .reference-line-modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .modal-body {
            padding: 20px;
            max-height: calc(80vh - 80px);
            overflow-y: auto;
        }

        .indicator-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .indicator-tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: #495057;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
        }

        .indicator-tab:hover {
            background: #f8f9fa;
        }

        .indicator-tab.active {
            background: white;
            color: #9b59b6;
            border-bottom-color: #9b59b6;
        }

        .reference-lines-list {
            margin-bottom: 20px;
        }

        .reference-line-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            background: white;
            transition: all 0.3s ease;
        }

        .reference-line-item:hover {
            border-color: #9b59b6;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.1);
        }

        .reference-line-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 15px;
            border: 2px solid #dee2e6;
        }

        .reference-line-info {
            flex: 1;
        }

        .reference-line-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .reference-line-value {
            color: #6c757d;
            font-size: 14px;
        }

        .reference-line-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-select, .btn-edit, .btn-delete {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .btn-select {
            background: #28a745;
            color: white;
        }

        .btn-select:hover {
            background: #218838;
        }

        .btn-edit {
            background: #17a2b8;
            color: white;
        }

        .btn-edit:hover {
            background: #138496;
        }

        .btn-delete {
            background: #dc3545;
            color: white;
        }

        .btn-delete:hover {
            background: #c82333;
        }

        .btn-edit:disabled, .btn-delete:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .current-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            font-weight: bold;
        }

        .btn-edit {
            background: #17a2b8;
            color: white;
        }

        .btn-edit:hover {
            background: #138496;
        }

        .btn-delete {
            background: #dc3545;
            color: white;
        }

        .btn-delete:hover {
            background: #c82333;
        }

        .add-line-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .add-line-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
        }

        /* è¾“å…¥è¡¨å•æ ·å¼ */
        .reference-line-form {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-group input[type="color"] {
            height: 40px;
            cursor: pointer;
            padding: 4px;
        }

        .form-group input[type="number"] {
            -moz-appearance: textfield;
        }

        .form-group input[type="number"]::-webkit-inner-spin-button,
        .form-group input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .form-group input:focus {
            outline: none;
            border-color: #9b59b6;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .default-notice {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .btn-save, .btn-cancel {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-save {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .btn-cancel {
            background: #6c757d;
            color: white;
        }

        .btn-save:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .reference-line-trigger {
                top: auto;
                bottom: 80px;
            }

            .reference-line-selector {
                top: auto;
                bottom: 130px;
                right: 10px;
                width: 250px;
            }

            .modal-content {
                width: 95%;
                margin: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>é—¨åº—ä¸šåŠ¡æŒ‡æ ‡èµ°åŠ¿åˆ†æç³»ç»Ÿ</h1>
            <p>2024å¹´6æœˆ - 2025å¹´10æœˆ æ•°æ®å¯è§†åŒ–åˆ†æ</p>
        </div>

        <div class="store-selector">
            <div class="store-tabs">
                <button class="store-tab" onclick="switchStore('å¹³å®‰', this)">å¹³å®‰åº—</button>
                <button class="store-tab active" onclick="switchStore('ä¾¨åŸ', this)">ä¾¨åŸåº—</button>
                <button class="store-tab" onclick="switchStore('åŒçº', this)">åŒçºåº—</button>
            </div>
        </div>

        <div class="content">
            <!-- å›¾è¡¨å¯¼èˆª -->
            <div class="chart-navigation-trigger" id="chartNavigationTrigger" title="å›¾è¡¨å¯¼èˆª">
                ğŸ“Š
            </div>

            <!-- å‚è€ƒçº¿ç®¡ç† -->
            <div class="reference-line-trigger" id="referenceLineTrigger" title="å‚è€ƒçº¿ç®¡ç†">
                ğŸ“
            </div>

            <div class="reference-line-selector" id="referenceLineSelector">
                <div class="selector-header">
                    <h5>ğŸ“ å½“å‰å‚è€ƒçº¿</h5>
                    <button class="close-btn" onclick="hideReferenceLineSelector()">Ã—</button>
                </div>
                <div id="referenceLineOptions">
                    <!-- åŠ¨æ€ç”Ÿæˆå‚è€ƒçº¿é€‰é¡¹ -->
                </div>
            </div>

            <!-- å‚è€ƒçº¿ç®¡ç†å¼¹çª— -->
            <div class="reference-line-modal" id="referenceLineModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>ğŸ“ å‚è€ƒçº¿ç®¡ç†</h3>
                        <button class="close-btn" onclick="closeReferenceLineModal()">Ã—</button>
                    </div>
                    <div class="modal-body">
                        <div class="indicator-tabs">
                            <button class="indicator-tab active" onclick="switchIndicatorTab('æ€»è¥æ”¶', this)">æ€»è¥æ”¶</button>
                            <button class="indicator-tab" onclick="switchIndicatorTab('ç¡®è®¤æ”¶å…¥', this)">ç¡®è®¤æ”¶å…¥</button>
                        </div>
                        <div class="reference-lines-list" id="referenceLinesList">
                            <!-- åŠ¨æ€ç”Ÿæˆå‚è€ƒçº¿åˆ—è¡¨ -->
                        </div>
                        <button class="add-line-btn" onclick="addNewReferenceLine()">+ æ·»åŠ æ–°å‚è€ƒçº¿</button>
                    </div>
                </div>
            </div>

            <div class="chart-navigation" id="chartNavigation">
                <div class="navigation-header">
                    <h4>ğŸ“Š å›¾è¡¨å¯¼èˆª</h4>
                </div>
                <div id="navigationList">
                    <!-- åŠ¨æ€ç”Ÿæˆå¯¼èˆªé¡¹ -->
                </div>
            </div>


            <!-- å›¾è¡¨ç½‘æ ¼ -->
            <div class="charts-grid" id="chartsGrid">
                <!-- åŠ¨æ€ç”Ÿæˆå›¾è¡¨ -->
            </div>
        </div>
    </div>

    <script>
        // é—¨åº—åŸå§‹æ•°æ®
        const storeData = `ï»¿é—¨åº—,å¹´ä»½,æœˆä»½,æ€»è¥æ”¶,ç¡®è®¤æ”¶å…¥,æ€»å®¢æµ,è€å®¢,Aç±»æ•°é‡,Aç±»è½¬åŒ–æ•°,Aç±»è½¬åŒ–åˆ†æ¯,Aç±»è½¬åŒ–ç‡,Aç±»ç¾å›¢ç‚¹è¯„,Aç±»è·¯è¿‡,Aç±»è€å¸¦æ–°,Aç±»å…¶ä»–,Bç±»æ•°é‡,Bç±»è½¬åŒ–æ•°,Bç±»è½¬åŒ–åˆ†æ¯,Bç±»è½¬åŒ–ç‡,Cç±»æ•°é‡,Cç±»è½¬åŒ–æ•°,Cç±»è½¬åŒ–åˆ†æ¯,Cç±»è½¬åŒ–ç‡,Dç±»æ•°é‡,Dç±»è½¬åŒ–æ•°,Dç±»è½¬åŒ–åˆ†æ¯,Dç±»è½¬åŒ–ç‡,æ€»æœ‰æ•ˆæœåŠ¡æ—¶é•¿,äººå‡æœåŠ¡æ—¶é•¿,æ‰“é±¼é‚€çº¦,ä¸»åŠ¨ä¸Šé—¨
å¹³å®‰,2024,6,180393,229957.52,287,182,105,7,64,10.94,47,46,12,0,24,5,22,22.73,47,12,42,28.57,111,2,102,1.96,398.92,1.39,0,182
å¹³å®‰,2024,7,188907,231999.16,270,180,90,6,52,11.54,44,32,13,1,27,7,23,30.43,40,9,37,24.32,113,1,108,0.93,389.01,1.44,5,175
å¹³å®‰,2024,8,314067,246841,269,196,73,8,41,19.51,28,22,19,4,20,8,21,38.1,48,21,46,45.65,129,5,122,4.1,418.75,1.56,61,136
å¹³å®‰,2024,9,254711.3,224437.85,241,159,82,6,47,12.77,28,38,16,0,15,4,16,25,38,16,38,42.11,106,8,101,7.92,367.08,1.52,60,99
å¹³å®‰,2024,10,199351,207426.5,228,156,72,9,43,20.93,35,21,16,0,12,4,11,36.36,36,14,36,38.89,108,0,99,0,341.5,1.5,56,100
å¹³å®‰,2024,11,353030,173567.8,199,152,47,4,27,14.81,11,18,14,4,10,4,11,36.36,31,12,37,32.43,111,32,112,28.57,282.75,1.42,39,113
å¹³å®‰,2024,12,195628,247758.73,252,183,69,5,41,12.2,22,25,21,1,7,4,7,57.14,25,12,22,54.55,151,7,133,5.26,376.5,1.49,73,110
å¹³å®‰,2025,1,249801,257916.6,249,171,78,5,43,11.63,38,26,14,0,9,6,10,60,35,8,30,26.67,128,3,119,2.52,363,1.46,60,112
å¹³å®‰,2025,2,145564,166363.35,197,145,52,1,33,3.03,13,27,11,0,6,2,7,28.57,36,13,36,36.11,103,4,94,4.26,281,1.43,45,100
å¹³å®‰,2025,3,163185.8,208588.8,259,192,67,2,44,4.55,15,33,18,1,22,7,21,33.33,28,7,28,25,142,3,132,2.27,354,1.37,87,105
å¹³å®‰,2025,4,110344,187065.5,225,165,60,1,34,2.94,27,17,16,0,11,1,10,10,33,5,32,15.62,121,2,107,1.87,317.08,1.41,87,78
å¹³å®‰,2025,5,224328.5,176459.86,218,137,81,7,48,14.58,29,37,15,0,11,5,12,41.67,29,15,31,48.39,97,10,90,11.11,304.5,1.4,51,86
å¹³å®‰,2025,6,171417,195897.71,248,149,99,7,64,10.94,33,57,7,1,10,7,9,77.78,28,5,23,21.74,112,3,103,2.91,328,1.32,46,104
å¹³å®‰,2025,7,160793,164630.62,207,143,64,14,51,27.45,24,30,6,4,4,2,4,50,27,9,25,36,112,5,104,4.81,299.5,1.45,48,95
å¹³å®‰,2025,8,232340,192993.76,258,181,77,8,46,17.39,23,36,13,5,17,7,14,50,28,15,27,55.56,136,5,117,4.27,345.42,1.34,58,123
å¹³å®‰,2025,9,180672,166100.92,211,151,60,8,34,23.53,23,21,16,0,12,2,11,18.18,24,6,21,28.57,115,7,111,6.31,285.25,1.35,64,87
å¹³å®‰,2025,10,159471,172176.06,209,161,48,2,33,6.06,20,19,7,2,20,4,12,33.33,27,13,25,52,114,2,103,1.94,289,1.38,66,95
å¹³å®‰å¹³å‡,,,204941,202952,237,165,72,100,745,13.22,,,,,,79,221,38.18,,192,536,36.01,,99,1857,5.35,,,60.07,102.87
,,,,,,,,,,13.42,,,,,,,,35.75,,,,35.82,,,,5.33,,,,
ä¾¨åŸ,2024,6,169890.8,133466.3,159,119,40,7,25,28,19,8,12,1,9,3,7,42.86,25,13,25,52,85,1,73,1.37,235.34,1.48,0,119
ä¾¨åŸ,2024,7,102113,104448.75,122,95,27,2,16,12.5,13,3,7,4,8,5,8,62.5,13,5,12,41.67,74,0,70,0,181,1.48,0,95
ä¾¨åŸ,2024,8,145687.6,136204.11,160,133,27,3,17,17.65,19,1,7,0,9,2,7,28.57,29,8,24,33.33,95,6,82,7.32,235.33,1.47,51,82
ä¾¨åŸ,2024,9,158498,123386.41,131,102,29,4,12,33.33,11,2,14,2,9,4,8,50,18,11,14,78.57,75,2,67,2.99,198.92,1.52,30,72
ä¾¨åŸ,2024,10,89802.1,106259.87,109,88,21,4,15,26.67,14,2,5,0,5,2,4,50,16,5,15,33.33,68,3,65,4.62,179.77,1.65,43,46
ä¾¨åŸ,2024,11,222469,119253.9,136,109,27,3,13,23.08,17,2,7,1,5,1,6,16.67,22,14,23,60.87,82,9,80,11.25,198,1.46,25,84
ä¾¨åŸ,2024,12,124434,148569.99,150,119,31,2,11,18.18,11,6,14,0,8,2,7,28.57,6,3,6,50,105,6,95,6.32,225.33,1.5,41,78
ä¾¨åŸ,2025,1,186540,176896.82,131,112,19,0,9,0,10,1,8,0,6,1,5,20,4,3,4,75,103,6,93,6.45,209,1.6,54,59
ä¾¨åŸ,2025,2,101598,95208,121,91,30,2,15,13.33,16,7,7,0,2,1,2,50,12,3,11,27.27,77,4,67,5.97,165.25,1.37,54,37
ä¾¨åŸ,2025,3,96334.8,120439.74,141,102,39,2,24,8.33,22,5,11,1,1,0,1,0,18,9,18,50,83,2,75,2.67,195.58,1.39,56,46
ä¾¨åŸ,2025,4,104971,149778,178,148,30,2,13,15.38,14,2,12,2,5,2,4,50,22,7,19,36.84,121,1,102,0.98,257,1.44,74,74
ä¾¨åŸ,2025,5,184716,153015.97,183,145,38,9,19,47.37,19,4,15,0,3,1,3,33.33,17,7,17,41.18,125,9,112,8.04,285.83,1.56,78,67
ä¾¨åŸ,2025,6,182115,131117.05,160,126,34,1,12,8.33,8,9,17,0,8,6,9,66.67,18,8,17,47.06,102,6,92,6.52,234.25,1.46,65,63
ä¾¨åŸ,2025,7,156814,137025.66,159,124,35,6,18,33.33,18,6,10,1,2,0,1,0,18,7,15,46.67,104,6,92,6.52,242.5,1.53,60,64
ä¾¨åŸ,2025,8,155187.6,155128.33,181,144,37,2,19,10.53,11,11,14,1,4,2,3,66.67,21,12,21,57.14,119,4,108,3.7,269.5,1.49,67,77
ä¾¨åŸ,2025,9,158824.4,136634.14,173,146,27,5,18,27.78,13,9,5,0,6,3,6,50,15,5,13,38.46,125,9,115,7.83,246.83,1.43,62,84
ä¾¨åŸ,2025,10,141240.2,129073.71,166,135,31,1,16,6.25,10,7,10,4,8,4,8,50,18,9,17,52.94,109,5,102,4.9,244.24,1.47,36,99
ä¾¨åŸå¹³å‡,,,145955,132700,151,120,31,,,19.41,,,,,,,,39.17,,,,48.37,,,,5.14,,,53.07,68.80
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
åŒçº,2024,6,98969,127417.33,124,108,16,2,8,25,5,1,6,4,4,2,4,50,20,9,18,50,84,3,82,3.66,204.5,1.65,0,108
åŒçº,2024,7,119792.4,130163.6,121,104,17,1,9,11.11,9,0,8,0,6,1,5,20,24,11,23,47.83,74,3,68,4.41,198.01,1.64,0,104
åŒçº,2024,8,155487,140415.98,140,126,14,4,7,57.14,8,0,6,0,2,1,2,50,23,12,20,60,101,6,96,6.25,232.42,1.66,42,84
åŒçº,2024,9,189761,136369.99,136,113,23,3,12,25,9,4,9,1,4,2,4,50,23,14,22,63.64,86,8,82,9.76,222.92,1.64,40,73
åŒçº,2024,10,167997,138437.18,149,133,16,2,7,28.57,6,1,7,2,6,3,5,60,12,4,11,36.36,115,8,106,7.55,239.58,1.61,60,73
åŒçº,2024,11,227946.8,129672.85,142,131,11,2,5,40,2,2,5,2,2,1,2,50,18,8,17,47.06,111,14,103,13.59,208.75,1.47,58,73
åŒçº,2024,12,227661,188549.04,187,163,24,4,10,40,15,0,9,0,3,3,3,100,19,11,18,61.11,141,9,134,6.72,277.18,1.48,75,88
åŒçº,2025,1,169161.8,211218.82,163,142,21,2,6,33.33,4,3,14,0,2,1,2,50,14,7,13,53.85,126,4,110,3.64,265.75,1.63,94,48
åŒçº,2025,2,115015.8,142807.81,153,135,18,1,13,7.69,13,2,3,0,0,0,0,0,10,6,10,60,125,2,107,1.87,241,1.58,66,69
åŒçº,2025,3,110268,153596.99,153,133,20,6,10,60,12,1,7,0,8,1,7,14.29,17,11,17,64.71,108,1,103,0.97,252.75,1.65,68,65
åŒçº,2025,4,90469,148513.94,146,129,17,2,13,15.38,12,0,4,1,2,0,2,0,15,4,12,33.33,113,4,103,3.88,243.83,1.67,72,58
åŒçº,2025,5,172999,155684.7,162,140,22,7,11,63.64,9,4,9,0,3,3,4,75,20,5,15,33.33,117,7,103,6.8,257.25,1.59,80,60
åŒçº,2025,6,134828,126725.72,142,125,17,3,7,42.86,8,1,8,0,4,1,3,33.33,14,8,14,57.14,107,5,101,4.95,219,1.54,58,67
åŒçº,2025,7,162218,145744.34,162,130,32,6,19,31.58,21,3,8,0,3,1,2,50,12,6,10,60,116,4,106,3.77,258.75,1.6,56,75
åŒçº,2025,8,168787.8,166903.38,180,165,15,3,6,50,4,3,8,0,2,2,2,100,22,7,19,36.84,141,7,131,5.34,281.5,1.56,91,74
åŒçº,2025,9,112111,145032.65,163,146,17,3,6,50,5,1,10,1,5,4,5,80,16,11,16,68.75,125,2,115,1.74,257.25,1.58,83,63
åŒçº,2025,10,154352,158508.12,171,146,25,4,13,30.77,10,5,10,0,3,0,3,0,22,7,20,35,121,9,110,8.18,267.08,1.56,63,83
ä¾¨åŸå¹³å‡,,,151637,149751,153,133,19,55,162,36.00,,,,,,26,55,46.04,,141,275,51.11,,96,1760,5.48,,,67.07,70.20
,,,,,,,,,,33.95,,,,,,,,47.27,,,,51.27,,,,5.45,,,,`

        let charts = {};
        let parsedData = [];
        let currentStore = 'ä¾¨åŸ';

        // å·¥å…·å‡½æ•° - ç§»åˆ°å‰é¢ä»¥é¿å…å‡½æ•°æœªå®šä¹‰é”™è¯¯
        function parseValue(value, isRate = false) {
            if (value === '' || value === null || value === undefined) return 0;
            const parsed = parseFloat(value);
            if (isNaN(parsed)) return 0;
            return parsed;
        }

        function formatValue(value, scale = 1) {
            if (scale === 10000) {
                return (value / scale).toFixed(1);
            }
            // å¯¹äºäººå‡æœåŠ¡æ—¶é•¿ç­‰å°æ•°å€¼ï¼Œä¿ç•™ä¸€ä½å°æ•°
            if (value < 10 && value % 1 !== 0) {
                return value.toFixed(1);
            }
            // å¯¹äºæ•´æ•°ï¼Œç¡®ä¿è¿”å›æ•´æ•°æ ¼å¼ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
            if (Number.isInteger(value) || (scale === 1 && Math.abs(value - Math.round(value)) < 0.000001)) {
                return Math.round(value);
            }
            // å…¶ä»–æƒ…å†µä¿ç•™åˆç†å°æ•°ä½
            if (scale === 1) {
                return value.toFixed(1);
            }
            return Math.round(value);
        }

        // æŒ‡æ ‡é…ç½® - æ’é™¤è½¬åŒ–ç±»ï¼Œå› ä¸ºè¦ç‰¹æ®Šå¤„ç†
        const indicators = [
            { key: 'æ€»è¥æ”¶', label: 'æ€»è¥æ”¶', unit: 'ä¸‡', scale: 10000 },
            { key: 'ç¡®è®¤æ”¶å…¥', label: 'ç¡®è®¤æ”¶å…¥', unit: 'ä¸‡', scale: 10000 },
            { key: 'æ€»å®¢æµ', label: 'æ€»å®¢æµ', unit: 'äºº', scale: 1 },
            { key: 'è€å®¢', label: 'è€å®¢æ•°é‡', unit: 'äºº', scale: 1 },
            { key: 'æ€»æœ‰æ•ˆæœåŠ¡æ—¶é•¿', label: 'æ€»æœ‰æ•ˆæœåŠ¡æ—¶é•¿', unit: 'å°æ—¶', scale: 1 },
            { key: 'äººå‡æœåŠ¡æ—¶é•¿', label: 'å®¢å‡æŠ¤ç†æ—¶é•¿', unit: 'å°æ—¶', scale: 1 },
            { key: 'æ‰“é±¼é‚€çº¦', label: 'æ‰“é±¼é‚€çº¦', unit: 'äºº', scale: 1 },
            { key: 'ä¸»åŠ¨ä¸Šé—¨', label: 'ä¸»åŠ¨ä¸Šé—¨', unit: 'äºº', scale: 1 }
        ];

        // ==================== å‚è€ƒçº¿ç®¡ç†ç³»ç»Ÿ ====================

        // å‚è€ƒçº¿ç®¡ç†å™¨
        const referenceLineManager = {
            // åˆå§‹åŒ–é»˜è®¤å‚è€ƒçº¿
            init() {
                // å¼ºåˆ¶ä½¿ç”¨æ–°çš„é»˜è®¤æ•°æ®ï¼ˆæ¸…é™¤æ—§æ•°æ®ï¼‰
                console.log('åˆå§‹åŒ–å‚è€ƒçº¿ç³»ç»Ÿï¼Œä½¿ç”¨æ–°çš„é»˜è®¤å€¼...');
                this.data = this.getDefaultData();
                this.save();
                this.updateSelector();
                this.setupEventListeners();
            },

            // æ£€æŸ¥æ˜¯å¦ä¸ºæ—§æ ¼å¼æ•°æ®
            isOldDataFormat(data) {
                // æ—§æ ¼å¼ï¼šç›´æ¥æœ‰ 'æ€»è¥æ”¶' å’Œ 'ç¡®è®¤æ”¶å…¥' é”®
                return data['æ€»è¥æ”¶'] || data['ç¡®è®¤æ”¶å…¥'];
            },

            // è¿ç§»æ—§æ•°æ®åˆ°æ–°æ ¼å¼
            migrateOldData(oldData) {
                const newData = this.getDefaultData();

                // å°†æ—§æ•°æ®åº”ç”¨åˆ°æ‰€æœ‰é—¨åº—
                ['å¹³å®‰', 'ä¾¨åŸ', 'åŒçº'].forEach(store => {
                    ['æ€»è¥æ”¶', 'ç¡®è®¤æ”¶å…¥'].forEach(indicator => {
                        if (oldData[indicator]) {
                            // ä¿ç•™æ—§çš„è‡ªå®šä¹‰å‚è€ƒçº¿
                            const customLines = oldData[indicator].lines?.filter(line => !line.isDefault) || [];
                            customLines.forEach(line => {
                                this.addLine(indicator, {
                                    name: line.name,
                                    value: line.value,
                                    color: line.color
                                }, store);
                            });
                        }
                    });
                });

                return newData;
            },

            // ç¡®ä¿æ‰€æœ‰é—¨åº—éƒ½æœ‰å®Œæ•´çš„é»˜è®¤æ•°æ®
            ensureCompleteDefaultData() {
                const defaultTemplate = this.getDefaultData();
                ['å¹³å®‰', 'ä¾¨åŸ', 'åŒçº'].forEach(store => {
                    if (!this.data[store]) {
                        this.data[store] = defaultTemplate[store];
                    } else {
                        ['æ€»è¥æ”¶', 'ç¡®è®¤æ”¶å…¥'].forEach(indicator => {
                            if (!this.data[store][indicator]) {
                                this.data[store][indicator] = defaultTemplate[store][indicator];
                            }
                        });
                    }
                });
            },

            // è·å–é»˜è®¤æ•°æ®ï¼ˆæŒ‰é—¨åº—ç»„ç»‡ï¼‰
            getDefaultData() {
                return {
                    'å¹³å®‰': {
                        'æ€»è¥æ”¶': {
                            lines: [
                                {
                                    id: 'default_balance',
                                    name: 'æ”¶æ”¯å¹³è¡¡çº¿',
                                    value: 215000,
                                    color: '#f39c12',
                                    isDefault: true
                                }
                            ],
                            selectedLineId: 'default_balance'
                        },
                        'ç¡®è®¤æ”¶å…¥': {
                            lines: [
                                {
                                    id: 'default_profit',
                                    name: 'ç›ˆäºå¹³è¡¡çº¿',
                                    value: 215000,
                                    color: '#f39c12',
                                    isDefault: true
                                }
                            ],
                            selectedLineId: 'default_profit'
                        }
                    },
                    'ä¾¨åŸ': {
                        'æ€»è¥æ”¶': {
                            lines: [
                                {
                                    id: 'default_balance',
                                    name: 'æ”¶æ”¯å¹³è¡¡çº¿',
                                    value: 140000,
                                    color: '#f39c12',
                                    isDefault: true
                                }
                            ],
                            selectedLineId: 'default_balance'
                        },
                        'ç¡®è®¤æ”¶å…¥': {
                            lines: [
                                {
                                    id: 'default_profit',
                                    name: 'ç›ˆäºå¹³è¡¡çº¿',
                                    value: 140000,
                                    color: '#f39c12',
                                    isDefault: true
                                }
                            ],
                            selectedLineId: 'default_profit'
                        }
                    },
                    'åŒçº': {
                        'æ€»è¥æ”¶': {
                            lines: [
                                {
                                    id: 'default_balance',
                                    name: 'æ”¶æ”¯å¹³è¡¡çº¿',
                                    value: 140000,
                                    color: '#f39c12',
                                    isDefault: true
                                }
                            ],
                            selectedLineId: 'default_balance'
                        },
                        'ç¡®è®¤æ”¶å…¥': {
                            lines: [
                                {
                                    id: 'default_profit',
                                    name: 'ç›ˆäºå¹³è¡¡çº¿',
                                    value: 140000,
                                    color: '#f39c12',
                                    isDefault: true
                                }
                            ],
                            selectedLineId: 'default_profit'
                        }
                    }
                };
            },

            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            save() {
                localStorage.setItem('referenceLines', JSON.stringify(this.data));
            },

            // è·å–å½“å‰é—¨åº—çš„å¹³è¡¡ç‚¹å€¼
            getBalancePoint(indicatorKey, storeName) {
                const storeData = this.data[storeName];
                if (!storeData || !storeData[indicatorKey]) return 0;

                const indicatorData = storeData[indicatorKey];
                if (!indicatorData.selectedLineId) return 0;

                const selectedLine = indicatorData.lines.find(line => line.id === indicatorData.selectedLineId);
                if (!selectedLine) return 0;

                return selectedLine.value;
            },

            // è·å–æŒ‡å®šé—¨åº—å’ŒæŒ‡æ ‡çš„æ‰€æœ‰å‚è€ƒçº¿
            getLines(indicatorKey, storeName = null) {
                if (storeName) {
                    return this.data[storeName]?.[indicatorKey]?.lines || [];
                }
                // å¦‚æœæ²¡æœ‰æŒ‡å®šé—¨åº—ï¼Œè¿”å›å½“å‰é—¨åº—çš„å‚è€ƒçº¿
                return this.data[currentStore]?.[indicatorKey]?.lines || [];
            },

            // è·å–å½“å‰é€‰ä¸­çš„å‚è€ƒçº¿
            getSelectedLine(indicatorKey, storeName = null) {
                const targetStore = storeName || currentStore;
                const storeData = this.data[targetStore];
                if (!storeData || !storeData[indicatorKey]) return null;

                const indicatorData = storeData[indicatorKey];
                if (!indicatorData.selectedLineId) return null;

                return indicatorData.lines.find(line => line.id === indicatorData.selectedLineId);
            },

            // æ·»åŠ æ–°å‚è€ƒçº¿
            addLine(indicatorKey, lineData, storeName = null) {
                const targetStore = storeName || currentStore;

                // ç¡®ä¿é—¨åº—æ•°æ®å­˜åœ¨
                if (!this.data[targetStore]) {
                    this.data[targetStore] = {};
                }

                if (!this.data[targetStore][indicatorKey]) {
                    this.data[targetStore][indicatorKey] = { lines: [], selectedLineId: '' };
                }

                const newLine = {
                    id: 'custom_' + Date.now(),
                    name: lineData.name,
                    value: parseFloat(lineData.value),
                    color: lineData.color || '#3498db',
                    isDefault: false
                };

                this.data[targetStore][indicatorKey].lines.push(newLine);
                this.save();
                return newLine;
            },

            // æ›´æ–°å‚è€ƒçº¿
            updateLine(indicatorKey, lineId, lineData, storeName = null) {
                const targetStore = storeName || currentStore;
                const storeData = this.data[targetStore];
                if (!storeData || !storeData[indicatorKey]) return false;

                const indicatorData = storeData[indicatorKey];
                const lineIndex = indicatorData.lines.findIndex(line => line.id === lineId);
                if (lineIndex === -1) return false;

                indicatorData.lines[lineIndex] = {
                    ...indicatorData.lines[lineIndex],
                    name: lineData.name,
                    value: parseFloat(lineData.value),
                    color: lineData.color || indicatorData.lines[lineIndex].color
                };

                this.save();
                return true;
            },

            // åˆ é™¤å‚è€ƒçº¿
            deleteLine(indicatorKey, lineId, storeName = null) {
                const targetStore = storeName || currentStore;
                const storeData = this.data[targetStore];
                if (!storeData || !storeData[indicatorKey]) return false;

                const indicatorData = storeData[indicatorKey];

                // ä¸å…è®¸åˆ é™¤é»˜è®¤å‚è€ƒçº¿
                const lineToDelete = indicatorData.lines.find(line => line.id === lineId);
                if (lineToDelete?.isDefault) return false;

                const lineIndex = indicatorData.lines.findIndex(line => line.id === lineId);
                if (lineIndex === -1) return false;

                indicatorData.lines.splice(lineIndex, 1);

                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„çº¿ï¼Œåˆ™é€‰ä¸­é»˜è®¤çº¿
                if (indicatorData.selectedLineId === lineId) {
                    const defaultLine = indicatorData.lines.find(line => line.isDefault);
                    indicatorData.selectedLineId = defaultLine ? defaultLine.id : '';
                }

                this.save();
                return true;
            },

            // é€‰æ‹©å‚è€ƒçº¿
            selectLine(indicatorKey, lineId, storeName = null) {
                const targetStore = storeName || currentStore;
                const storeData = this.data[targetStore];
                if (!storeData || !storeData[indicatorKey]) {
                    console.error(`é€‰æ‹©å‚è€ƒçº¿å¤±è´¥: é—¨åº— ${targetStore} æˆ–æŒ‡æ ‡ ${indicatorKey} ä¸å­˜åœ¨`);
                    return false;
                }

                const indicatorData = storeData[indicatorKey];
                const line = indicatorData.lines.find(l => l.id === lineId);
                if (!line) {
                    console.error(`é€‰æ‹©å‚è€ƒçº¿å¤±è´¥: å‚è€ƒçº¿ ${lineId} ä¸å­˜åœ¨`);
                    return false;
                }

                const oldLineId = indicatorData.selectedLineId;
                indicatorData.selectedLineId = lineId;

                console.log(`åˆ‡æ¢å‚è€ƒçº¿: ${targetStore} ${indicatorKey} ä» ${oldLineId} åˆ‡æ¢åˆ° ${lineId} (${line.name}: ${formatValue(line.value/10000, 1)}ä¸‡)`);

                this.save();

                // é‡æ–°åŠ è½½å‚è€ƒçº¿åˆ—è¡¨
                if (targetStore === currentStore) {
                    loadReferenceLines();
                }

                this.updateSelector();

                // é‡æ–°è®¡ç®—å’Œæ›´æ–°å›¾è¡¨
                updateAllCharts(getCurrentStoreData());

                return true;
            },

            // æ›´æ–°å‚è€ƒçº¿é€‰æ‹©å™¨
            updateSelector() {
                const container = document.getElementById('referenceLineOptions');
                if (!container) return;

                let html = '';

                // æ˜¾ç¤ºå½“å‰é—¨åº—ä¿¡æ¯
                html += `<div class="current-store-info">å½“å‰é—¨åº—ï¼š${currentStore}</div>`;

                ['æ€»è¥æ”¶', 'ç¡®è®¤æ”¶å…¥'].forEach(indicatorKey => {
                    const lines = this.getLines(indicatorKey, currentStore);
                    const selectedLineId = this.data[currentStore]?.[indicatorKey]?.selectedLineId;

                    if (lines.length > 0) {
                        const displayName = indicatorKey === 'æ€»è¥æ”¶' ? 'è¥æ”¶' : 'ç¡®è®¤æ”¶å…¥';

                        html += `
                            <div class="indicator-section">
                                <div class="indicator-title">${displayName}</div>
                                <div class="reference-options">
                        `;

                        lines.forEach(line => {
                            const isSelected = line.id === selectedLineId;
                            html += `
                                <div class="reference-option-item ${isSelected ? 'active' : ''}"
                                     data-indicator="${indicatorKey}"
                                     data-line-id="${line.id}">
                                    <div class="reference-option-color" style="background-color: ${line.color}"></div>
                                    <div class="reference-option-info">
                                        <div class="reference-option-name">${line.name}</div>
                                        <div class="reference-option-value">${formatValue(line.value / 10000, 1)}ä¸‡</div>
                                    </div>
                                </div>
                            `;
                        });

                        html += `
                                </div>
                            </div>
                        `;
                    }
                });

                container.innerHTML = html;

                // æ·»åŠ é€‰æ‹©äº‹ä»¶
                container.querySelectorAll('.reference-option-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const indicatorKey = item.dataset.indicator;
                        const lineId = item.dataset.lineId;
                        console.log(`é€‰æ‹©å‚è€ƒçº¿: ${indicatorKey}, ${lineId}, é—¨åº—: ${currentStore}`);
                        this.selectLine(indicatorKey, lineId, currentStore);
                    });
                });
            },

            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners() {
                // å‚è€ƒçº¿ç®¡ç†è§¦å‘æŒ‰é’®ï¼ˆå•å‡»æ‰“å¼€ç®¡ç†å¼¹çª—ï¼‰
                const trigger = document.getElementById('referenceLineTrigger');
                if (trigger) {
                    trigger.addEventListener('click', () => {
                        openReferenceLineModal();
                    });

                    // å³é”®ç‚¹å‡»æ‰“å¼€å¿«é€Ÿé€‰æ‹©å™¨
                    trigger.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showReferenceLineSelector();
                    });

                    // åŒå‡»ä¹Ÿå¯ä»¥æ‰“å¼€é€‰æ‹©å™¨
                    trigger.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        showReferenceLineSelector();
                    });

                    // Shift+ç‚¹å‡»é‡ç½®æ•°æ®ï¼ˆè°ƒè¯•ç”¨ï¼‰
                    trigger.addEventListener('click', (e) => {
                        if (e.shiftKey) {
                            e.preventDefault();
                            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰å‚è€ƒçº¿æ•°æ®å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰è‡ªå®šä¹‰è®¾ç½®ï¼')) {
                                this.resetAllData();
                            }
                        }
                    });
                }

                // ç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹å…³é—­é€‰æ‹©å™¨
                document.addEventListener('click', (e) => {
                    const selector = document.getElementById('referenceLineSelector');
                    const trigger = document.getElementById('referenceLineTrigger');

                    if (selector && trigger &&
                        !selector.contains(e.target) &&
                        e.target !== trigger &&
                        !trigger.contains(e.target)) {
                        hideReferenceLineSelector();
                    }
                });

                // ESCé”®å…³é—­å¼¹çª—å’Œé€‰æ‹©å™¨
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeReferenceLineModal();
                        hideReferenceLineSelector();
                    }
                });
            },

            // é‡ç½®æ‰€æœ‰æ•°æ®ï¼ˆè°ƒè¯•ç”¨ï¼‰
            resetAllData() {
                console.log('é‡ç½®æ‰€æœ‰å‚è€ƒçº¿æ•°æ®...');
                localStorage.removeItem('referenceLines');
                this.data = this.getDefaultData();
                this.save();
                this.updateSelector();
                loadReferenceLines();
                updateAllCharts(getCurrentStoreData());
                console.log('å‚è€ƒçº¿æ•°æ®å·²é‡ç½®');
            }
        };

        // ==================== å‚è€ƒçº¿UIç®¡ç†å‡½æ•° ====================

        let currentIndicatorTab = 'æ€»è¥æ”¶';
        let editingLineId = null;

        // æ‰“å¼€å‚è€ƒçº¿ç®¡ç†å¼¹çª—
        function openReferenceLineModal() {
            document.getElementById('referenceLineModal').classList.add('show');
            loadReferenceLines();
        }

        // å…³é—­å‚è€ƒçº¿ç®¡ç†å¼¹çª—
        function closeReferenceLineModal() {
            document.getElementById('referenceLineModal').classList.remove('show');
            editingLineId = null;
        }

        // æ˜¾ç¤ºå‚è€ƒçº¿é€‰æ‹©å™¨
        function showReferenceLineSelector() {
            document.getElementById('referenceLineSelector').classList.add('show');
        }

        // éšè—å‚è€ƒçº¿é€‰æ‹©å™¨
        function hideReferenceLineSelector() {
            document.getElementById('referenceLineSelector').classList.remove('show');
        }

        // åˆ‡æ¢æŒ‡æ ‡æ ‡ç­¾
        function switchIndicatorTab(indicatorKey, element) {
            currentIndicatorTab = indicatorKey;

            // æ›´æ–°æ ‡ç­¾çŠ¶æ€
            document.querySelectorAll('.indicator-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            element.classList.add('active');

            // é‡æ–°åŠ è½½å‚è€ƒçº¿åˆ—è¡¨
            loadReferenceLines();
        }

        // åŠ è½½å‚è€ƒçº¿åˆ—è¡¨
        function loadReferenceLines() {
            const container = document.getElementById('referenceLinesList');
            if (!container) return;

            const lines = referenceLineManager.getLines(currentIndicatorTab, currentStore);
            const selectedLineId = referenceLineManager.data[currentStore]?.[currentIndicatorTab]?.selectedLineId;

            console.log(`åŠ è½½å‚è€ƒçº¿åˆ—è¡¨ - é—¨åº—: ${currentStore}, æŒ‡æ ‡: ${currentIndicatorTab}, çº¿æ¡æ•°é‡: ${lines.length}`);

            let html = '';

            lines.forEach(line => {
                const isSelected = line.id === selectedLineId;
                html += `
                    <div class="reference-line-item ${isSelected ? 'selected' : ''}" data-line-id="${line.id}">
                        <div class="reference-line-color" style="background-color: ${line.color}"></div>
                        <div class="reference-line-info">
                            <div class="reference-line-name">
                                ${line.name} ${line.isDefault ? '(é»˜è®¤)' : ''}
                                ${isSelected ? '<span class="current-badge">å½“å‰</span>' : ''}
                            </div>
                            <div class="reference-line-value">${formatValue(line.value / 10000, 1)}ä¸‡å…ƒ</div>
                        </div>
                        <div class="reference-line-actions">
                            ${!isSelected ? `<button class="btn-select" onclick="selectReferenceLine('${line.id}')">è®¾ä¸ºå½“å‰</button>` : ''}
                            <button class="btn-edit" onclick="editReferenceLine('${line.id}')">ç¼–è¾‘</button>
                            <button class="btn-delete" onclick="deleteReferenceLine('${line.id}')" ${line.isDefault ? 'disabled' : ''}>åˆ é™¤</button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;

            // æ·»åŠ é€‰æ‹©äº‹ä»¶
            container.querySelectorAll('.reference-line-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('btn-edit') || e.target.classList.contains('btn-delete')) {
                        return;
                    }
                    const lineId = item.dataset.lineId;
                    referenceLineManager.selectLine(currentIndicatorTab, lineId, currentStore);
                });
            });
        }

        // æ·»åŠ æ–°å‚è€ƒçº¿
        function addNewReferenceLine() {
            const formHtml = `
                <div class="reference-line-form" id="addLineForm">
                    <div class="form-group">
                        <label>å‚è€ƒçº¿åç§°</label>
                        <input type="text" id="lineName" placeholder="ä¾‹å¦‚ï¼šç›®æ ‡çº¿ã€è­¦æˆ’çº¿" required>
                    </div>
                    <div class="form-group">
                        <label>å‚è€ƒçº¿æ•°å€¼ï¼ˆå…ƒï¼‰</label>
                        <input type="number" id="lineValue" placeholder="ä¾‹å¦‚ï¼š200000" min="0" required>
                    </div>
                    <div class="form-group">
                        <label>é¢œè‰²</label>
                        <input type="color" id="lineColor" value="#3498db" style="width: 100%; height: 40px; cursor: pointer;">
                    </div>
                    <div class="form-actions">
                        <button class="btn-cancel" onclick="cancelAddLine()">å–æ¶ˆ</button>
                        <button class="btn-save" onclick="saveNewLine()">ä¿å­˜</button>
                    </div>
                </div>
            `;

            // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¡¨å•
            if (document.getElementById('addLineForm')) {
                document.getElementById('addLineForm').remove();
            }

            // æ’å…¥æ–°è¡¨å•
            const container = document.getElementById('referenceLinesList');
            const addLineBtn = document.querySelector('.add-line-btn');
            if (addLineBtn) {
                // åœ¨æ·»åŠ æŒ‰é’®ä¹‹å‰æ’å…¥è¡¨å•
                addLineBtn.insertAdjacentHTML('beforebegin', formHtml);
            } else {
                // å¦‚æœæ‰¾ä¸åˆ°æ·»åŠ æŒ‰é’®ï¼Œç›´æ¥æ’å…¥åˆ°å®¹å™¨æœ«å°¾
                container.insertAdjacentHTML('beforeend', formHtml);
            }

            console.log('æ·»åŠ å‚è€ƒçº¿è¡¨å•å·²æ’å…¥');
        }

        // ä¿å­˜æ–°å‚è€ƒçº¿
        function saveNewLine() {
            const name = document.getElementById('lineName').value.trim();
            const value = document.getElementById('lineValue').value;
            const color = document.getElementById('lineColor').value;

            if (!name || !value) {
                alert('è¯·å¡«å†™å®Œæ•´çš„å‚è€ƒçº¿ä¿¡æ¯');
                return;
            }

            referenceLineManager.addLine(currentIndicatorTab, { name, value, color }, currentStore);

            // ç§»é™¤è¡¨å•
            document.getElementById('addLineForm')?.remove();

            // é‡æ–°åŠ è½½å‚è€ƒçº¿åˆ—è¡¨å’Œé€‰æ‹©å™¨
            loadReferenceLines();
            referenceLineManager.updateSelector();

            // é‡æ–°æ›´æ–°å›¾è¡¨ä»¥æ˜¾ç¤ºæ–°å‚è€ƒçº¿
            updateAllCharts(getCurrentStoreData());
        }

        // å–æ¶ˆæ·»åŠ 
        function cancelAddLine() {
            document.getElementById('addLineForm')?.remove();
        }

        // ç¼–è¾‘å‚è€ƒçº¿
        function editReferenceLine(lineId) {
            const lines = referenceLineManager.getLines(currentIndicatorTab, currentStore);
            const line = lines.find(l => l.id === lineId);

            if (!line) return;

            editingLineId = lineId;

            const formHtml = `
                <div class="reference-line-form" id="editLineForm">
                    ${line.isDefault ? '<div class="default-notice">âš ï¸ æ­£åœ¨ç¼–è¾‘é»˜è®¤å‚è€ƒçº¿ï¼Œä¿®æ”¹å°†å½±å“è¯¥é—¨åº—çš„æ‰€æœ‰è®¡ç®—</div>' : ''}
                    <div class="form-group">
                        <label>å‚è€ƒçº¿åç§°</label>
                        <input type="text" id="editLineName" value="${line.name}" ${line.isDefault ? 'disabled' : ''}>
                        ${line.isDefault ? '<small style="color: #666; font-size: 11px;">é»˜è®¤å‚è€ƒçº¿åç§°ä¸å¯ä¿®æ”¹</small>' : ''}
                    </div>
                    <div class="form-group">
                        <label>å‚è€ƒçº¿æ•°å€¼ï¼ˆå…ƒï¼‰</label>
                        <input type="number" id="editLineValue" value="${line.value}" min="0">
                        <small style="color: #666; font-size: 11px;">è®¾ç½®è¯¥é—¨åº—çš„å‚è€ƒçº¿åŸºå‡†å€¼</small>
                    </div>
                    ${!line.isDefault ? `
                    <div class="form-group">
                        <label>é¢œè‰²</label>
                        <input type="color" id="editLineColor" value="${line.color}" style="width: 100%; height: 40px; cursor: pointer;">
                    </div>
                    ` : '<input type="hidden" id="editLineColor" value="' + line.color + '">'}
                    <div class="form-actions">
                        <button class="btn-cancel" onclick="cancelEditLine()">å–æ¶ˆ</button>
                        <button class="btn-save" onclick="saveEditLine()">ä¿å­˜</button>
                    </div>
                </div>
            `;

            // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¡¨å•
            if (document.getElementById('editLineForm')) {
                document.getElementById('editLineForm').remove();
            }

            // æ’å…¥ç¼–è¾‘è¡¨å•
            const container = document.getElementById('referenceLinesList');
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = formHtml;

            // æ‰¾åˆ°å¯¹åº”çš„é¡¹ç›®å¹¶æ’å…¥è¡¨å•
            const targetItem = container.querySelector(`[data-line-id="${lineId}"]`);
            if (targetItem) {
                targetItem.insertAdjacentHTML('afterend', formHtml);
            }
        }

        // ä¿å­˜ç¼–è¾‘
        function saveEditLine() {
            const name = document.getElementById('editLineName')?.value?.trim() || '';
            const value = document.getElementById('editLineValue').value;
            const color = document.getElementById('editLineColor')?.value || '';

            if (!value || parseFloat(value) < 0) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å‚è€ƒçº¿æ•°å€¼ï¼ˆå¤§äºç­‰äº0ï¼‰');
                return;
            }

            const updateData = { value: parseFloat(value) };

            // åªæœ‰éé»˜è®¤å‚è€ƒçº¿æ‰èƒ½ä¿®æ”¹åç§°å’Œé¢œè‰²
            const line = referenceLineManager.getLines(currentIndicatorTab, currentStore).find(l => l.id === editingLineId);
            if (!line.isDefault) {
                if (!name) {
                    alert('è¯·å¡«å†™å‚è€ƒçº¿åç§°');
                    return;
                }
                updateData.name = name;
                updateData.color = color;
            }

            const success = referenceLineManager.updateLine(currentIndicatorTab, editingLineId, updateData, currentStore);
            if (success) {
                editingLineId = null;

                // ç§»é™¤ç¼–è¾‘è¡¨å•
                document.getElementById('editLineForm')?.remove();

                // é‡æ–°åŠ è½½å‚è€ƒçº¿åˆ—è¡¨å’Œé€‰æ‹©å™¨
                loadReferenceLines();
                referenceLineManager.updateSelector();

                // é‡æ–°æ›´æ–°å›¾è¡¨ä»¥æ˜¾ç¤ºä¿®æ”¹åçš„å‚è€ƒçº¿
                updateAllCharts(getCurrentStoreData());

                // æ˜¾ç¤ºæˆåŠŸæç¤º
                const lineName = line.isDefault ? 'é»˜è®¤å‚è€ƒçº¿' : updateData.name;
                console.log(`${lineName}å·²æ›´æ–°ä¸º: ${formatValue(parseFloat(value) / 10000, 1)}ä¸‡`);
            } else {
                alert('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }

        // å–æ¶ˆç¼–è¾‘
        function cancelEditLine() {
            document.getElementById('editLineForm')?.remove();
            editingLineId = null;
        }

        // åˆ é™¤å‚è€ƒçº¿
        function deleteReferenceLine(lineId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å‚è€ƒçº¿å—ï¼Ÿ')) return;

            const success = referenceLineManager.deleteLine(currentIndicatorTab, lineId, currentStore);
            if (success) {
                loadReferenceLines();
            } else {
                alert('æ— æ³•åˆ é™¤é»˜è®¤å‚è€ƒçº¿');
            }
        }

        // é€‰æ‹©å‚è€ƒçº¿ï¼ˆè®¾ä¸ºå½“å‰ï¼‰
        function selectReferenceLine(lineId) {
            console.log(`ç‚¹å‡»è®¾ä¸ºå½“å‰æŒ‰é’®: é—¨åº—=${currentStore}, æŒ‡æ ‡=${currentIndicatorTab}, çº¿ID=${lineId}`);
            const success = referenceLineManager.selectLine(currentIndicatorTab, lineId, currentStore);
            if (success) {
                const line = referenceLineManager.getSelectedLine(currentIndicatorTab, currentStore);
                console.log(`âœ… æˆåŠŸåˆ‡æ¢åˆ°å‚è€ƒçº¿: ${line.name} (${formatValue(line.value/10000, 1)}ä¸‡)`);
            } else {
                console.log(`âŒ åˆ‡æ¢å‚è€ƒçº¿å¤±è´¥`);
            }
        }


        // è½¬åŒ–ç±»æŒ‡æ ‡é…ç½®
        const conversionIndicators = [
            { type: 'A', numKey: 'Aç±»è½¬åŒ–æ•°', denomKey: 'Aç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Aç±»è½¬åŒ–ç‡', color: '#FF6384' },
            { type: 'B', numKey: 'Bç±»è½¬åŒ–æ•°', denomKey: 'Bç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Bç±»è½¬åŒ–ç‡', color: '#36A2EB' },
            { type: 'C', numKey: 'Cç±»è½¬åŒ–æ•°', denomKey: 'Cç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Cç±»è½¬åŒ–ç‡', color: '#FFCE56' },
            { type: 'D', numKey: 'Dç±»è½¬åŒ–æ•°', denomKey: 'Dç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Dç±»è½¬åŒ–ç‡', color: '#4BC0C0' }
        ];

        // è€å®¢åˆ†ææŒ‡æ ‡
        const customerTypeIndicators = [
            { key: 'è€å®¢', label: 'è€å®¢', color: '#FF6384' },
            { key: 'Bç±»æ•°é‡', label: 'Bç±»', color: '#36A2EB' },
            { key: 'Cç±»æ•°é‡', label: 'Cç±»', color: '#FFCE56' },
            { key: 'Dç±»æ•°é‡', label: 'Dç±»', color: '#4BC0C0' }
        ];

        // Aç±»å››åˆä¸€æŒ‡æ ‡
        const aClassIndicators = [
            { key: 'Aç±»æ•°é‡', label: 'æ–°å®¢æ€»æ•°', color: '#FF6384' },
            { key: 'Aç±»ç¾å›¢ç‚¹è¯„', label: 'ç¾å›¢ç‚¹è¯„', color: '#36A2EB' },
            { key: 'Aç±»è·¯è¿‡', label: 'è·¯è¿‡', color: '#FFCE56' },
            { key: 'Aç±»è€å¸¦æ–°', label: 'è€å¸¦æ–°', color: '#4BC0C0' },
            { key: 'Aç±»å…¶ä»–', label: 'å…¶ä»–', color: '#9966FF' }
        ];

        // åˆå§‹åŒ–
        function init() {
            // æ³¨å†ŒDataLabelsæ’ä»¶
            Chart.register(ChartDataLabels);

            parsedData = parseData();

            // åˆå§‹åŒ–å‚è€ƒçº¿ç®¡ç†ç³»ç»Ÿ
            referenceLineManager.init();

            updateStoreData('ä¾¨åŸ');
        }

        // è§£ææ•°æ®
        function parseData() {
            const lines = storeData.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const record = {};
                headers.forEach((header, index) => {
                    record[header] = values[index];
                });
                data.push(record);
            }

            return data;
        }

        // åˆ‡æ¢é—¨åº—
        function switchStore(store, element) {
            currentStore = store;

            // æ›´æ–°æ ‡ç­¾çŠ¶æ€
            document.querySelectorAll('.store-tab').forEach(tab => tab.classList.remove('active'));
            element.classList.add('active');

            // æ›´æ–°å‚è€ƒçº¿é€‰æ‹©å™¨æ˜¾ç¤º
            referenceLineManager.updateSelector();

            updateStoreData(store);
        }

        // è·å–å½“å‰é—¨åº—æ•°æ®
        function getCurrentStoreData() {
            return parsedData.filter(item => item['é—¨åº—'] === currentStore).filter(item => {
                const year = parseInt(item['å¹´ä»½']);
                const month = parseInt(item['æœˆä»½']);
                const fishInvite = parseValue(item['æ‰“é±¼é‚€çº¦']);
                return !(year === 2024 && month <= 7 && fishInvite === 0);
            });
        }


      // æ›´æ–°é—¨åº—æ•°æ®
        function updateStoreData(store) {
            let storeData = parsedData.filter(item => item['é—¨åº—'] === store);

            // ç§»é™¤æ‰“é±¼æ•°æ®çš„24å¹´6-7æœˆï¼ˆæ‰“é±¼é‚€çº¦ä¸º0çš„æœˆä»½ï¼‰
            storeData = storeData.filter(item => {
                const year = parseInt(item['å¹´ä»½']);
                const month = parseInt(item['æœˆä»½']);
                const fishInvite = parseValue(item['æ‰“é±¼é‚€çº¦']);
                return !(year === 2024 && month <= 7 && fishInvite === 0);
            });

            // æ›´æ–°å›¾è¡¨
            updateAllCharts(storeData);
        }


        // æ›´æ–°æ‰€æœ‰å›¾è¡¨
        function updateAllCharts(storeData) {
            const container = document.getElementById('chartsGrid');
            container.innerHTML = '';

            // æ¸…é™¤ä¹‹å‰çš„å›¾è¡¨
            Object.values(charts).forEach(chart => {
                if (chart) chart.destroy();
            });
            charts = {};

            // åˆ›å»ºå›¾è¡¨å¯¼èˆª
            createChartNavigation();

            // åˆ›å»ºå•ä¸ªæŒ‡æ ‡å›¾è¡¨
            indicators.forEach((indicator, index) => {
                createIndicatorChart(container, storeData, indicator, `chart${index}`);

                // ä¸ºè¥æ”¶å’Œç¡®è®¤æ”¶å…¥æ·»åŠ ç°é‡‘æµè¡¨æ ¼
                if (indicator.key === 'æ€»è¥æ”¶' || indicator.key === 'ç¡®è®¤æ”¶å…¥') {
                    // è·å–å¯¹åº”çš„å¹³è¡¡ç‚¹ï¼ˆä½¿ç”¨å‚è€ƒçº¿ç®¡ç†ç³»ç»Ÿï¼‰
                    const storeName = storeData.length > 0 ? storeData[0]['é—¨åº—'] : currentStore;
                    const balancePoint = referenceLineManager.getBalancePoint(indicator.key, storeName);

                    // åˆ›å»ºç°é‡‘æµè¡¨æ ¼ï¼ˆç°åœ¨åŒ…å«å›¾è¡¨ï¼‰
                    createCashFlowTable(container, storeData, indicator, balancePoint);
                }
            });

            // åˆ›å»ºè½¬åŒ–ç±»æŒ‡æ ‡å›¾è¡¨
            conversionIndicators.forEach((indicator, index) => {
                createConversionChart(container, storeData, indicator, `conversion${index}`);
            });

            // åˆ›å»ºç»„åˆæŒ‡æ ‡å›¾è¡¨
            createCustomerTypeChart(container, storeData);
            createAClassCombinedChart(container, storeData);
        }

        // åˆ›å»ºå›¾è¡¨å¯¼èˆª
        function createChartNavigation() {
            const navContainer = document.getElementById('navigationList');
            navContainer.innerHTML = '';

            // åŸºç¡€æŒ‡æ ‡å¯¼èˆª
            const basicGroup = document.createElement('div');
            basicGroup.className = 'nav-group';

            const basicTitle = document.createElement('div');
            basicTitle.className = 'nav-group-title';
            basicTitle.textContent = 'åŸºç¡€æŒ‡æ ‡';
            basicGroup.appendChild(basicTitle);

            indicators.forEach((indicator, index) => {
                const navItem = document.createElement('a');
                navItem.className = 'nav-item';
                navItem.href = '#chart' + index;
                navItem.textContent = indicator.label;
                navItem.onclick = function(e) {
                    e.preventDefault();
                    scrollToChart('chart' + index);
                };
                basicGroup.appendChild(navItem);
            });

            navContainer.appendChild(basicGroup);

            // è½¬åŒ–åˆ†æå¯¼èˆª
            const conversionGroup = document.createElement('div');
            conversionGroup.className = 'nav-group';

            const conversionTitle = document.createElement('div');
            conversionTitle.className = 'nav-group-title';
            conversionTitle.textContent = 'è½¬åŒ–åˆ†æ';
            conversionGroup.appendChild(conversionTitle);

            conversionIndicators.forEach((indicator, index) => {
                const navItem = document.createElement('a');
                navItem.className = 'nav-item';
                navItem.href = '#conversion' + index;
                navItem.textContent = indicator.type + 'ç±»è½¬åŒ–åˆ†æ';
                navItem.onclick = function(e) {
                    e.preventDefault();
                    scrollToChart('conversion' + index);
                };
                conversionGroup.appendChild(navItem);
            });

            navContainer.appendChild(conversionGroup);

            // ç»„åˆæŒ‡æ ‡å¯¼èˆª
            const combinedGroup = document.createElement('div');
            combinedGroup.className = 'nav-group';

            const combinedTitle = document.createElement('div');
            combinedTitle.className = 'nav-group-title';
            combinedTitle.textContent = 'ç»„åˆåˆ†æ';
            combinedGroup.appendChild(combinedTitle);

            const customerTypeNav = document.createElement('a');
            customerTypeNav.className = 'nav-item';
            customerTypeNav.href = '#customerTypeChart';
            customerTypeNav.textContent = 'è€å®¢åˆ†æ';
            customerTypeNav.onclick = function(e) {
                e.preventDefault();
                scrollToChart('customerTypeChart');
            };
            combinedGroup.appendChild(customerTypeNav);

            const newCustomerNav = document.createElement('a');
            newCustomerNav.className = 'nav-item';
            newCustomerNav.href = '#aClassCombinedChart';
            newCustomerNav.textContent = 'æ–°å®¢åˆ†æ';
            newCustomerNav.onclick = function(e) {
                e.preventDefault();
                scrollToChart('aClassCombinedChart');
            };
            combinedGroup.appendChild(newCustomerNav);

            navContainer.appendChild(combinedGroup);
        }

        // æ»šåŠ¨åˆ°æŒ‡å®šå›¾è¡¨
        function scrollToChart(chartId) {
            // ç§»é™¤æ‰€æœ‰æ´»è·ƒçŠ¶æ€
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // æ·»åŠ æ´»è·ƒçŠ¶æ€
            const activeItem = document.querySelector(`[href="#${chartId}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }

            // æ»šåŠ¨åˆ°å›¾è¡¨
            let targetElement;

            // å¯¹äºè½¬åŒ–åˆ†æï¼Œå…ˆæŸ¥æ‰¾å­å›¾è¡¨ï¼Œå†æŸ¥æ‰¾ä¸»å›¾è¡¨
            if (chartId.includes('conversion')) {
                targetElement = document.getElementById(chartId + '_conversion') ||
                              document.getElementById(chartId + '_rate') ||
                              document.getElementById(chartId);
            } else {
                targetElement = document.getElementById(chartId);
            }

            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });

                // æ·»åŠ é«˜äº®æ•ˆæœ - å¯¹äºè½¬åŒ–åˆ†æå’Œç»„åˆåˆ†æï¼Œè¦é«˜äº®æ•´ä¸ªç‰¹æ®Šå›¾è¡¨å®¹å™¨
                let chartContainer;
                if (chartId.includes('conversion') || chartId === 'customerTypeChart' || chartId === 'aClassCombinedChart') {
                    chartContainer = targetElement.closest('.special-chart');
                } else {
                    chartContainer = targetElement.closest('.chart-container');
                }

                if (chartContainer) {
                    chartContainer.style.transition = 'transform 0.3s ease';
                    chartContainer.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        chartContainer.style.transform = 'scale(1)';
                    }, 500);
                }
            }
        }

        // åˆ›å»ºè€å®¢åˆ†æå›¾è¡¨
        function createCustomerTypeChart(container, storeData) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container special-chart';

            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">è€å®¢åˆ†æ</div>
                        <div class="chart-subtitle">è€å®¢åŠå„ç±»å®¢æˆ·æ•°é‡èµ°åŠ¿</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="customerTypeChart"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            const ctx = document.getElementById('customerTypeChart').getContext('2d');

            // å‚è€ƒåŸºç¡€æŒ‡æ ‡çš„å¤„ç†æ–¹å¼ï¼Œæ¯ä¸ªæ•°æ®é›†ç‹¬ç«‹å¤„ç†
            const datasets = [];

            customerTypeIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                const borderColor = indicator.color;
                const backgroundColor = indicator.color + '20';

                datasets.push({
                    label: indicator.label,
                    data: values,
                    borderColor: borderColor,
                    backgroundColor: backgroundColor,
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: borderColor,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    tension: 0.2,
                    fill: false
                });
            });

            charts.customerTypeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true, // å¯ç”¨å›¾ä¾‹ï¼Œè®©ç”¨æˆ·å¯ä»¥æ§åˆ¶æ˜¾ç¤º/éšè—
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                },
                                boxWidth: 12,
                                padding: 15,
                                // è‡ªå®šä¹‰å›¾ä¾‹ç”Ÿæˆï¼Œåªæ˜¾ç¤ºä¸»è¦æ•°æ®é›†
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        // åªè¿”å›å‰customerTypeIndicators.lengthä¸ªæ•°æ®é›†ï¼ˆä¸»è¦æ•°æ®é›†ï¼‰
                                        return data.datasets.slice(0, customerTypeIndicators.length).map((dataset, i) => ({
                                            text: dataset.label,
                                            fillStyle: dataset.borderColor,
                                            strokeStyle: dataset.borderColor,
                                            lineWidth: dataset.borderWidth,
                                            pointStyle: 'rectRounded',
                                            hidden: !chart.isDatasetVisible(i),
                                            datasetIndex: i
                                        }));
                                    }
                                    return [];
                                }
                            },
                            // è‡ªå®šä¹‰ç‚¹å‡»å¤„ç†
                            onClick: function(e, legendItem, legend) {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);

                                // åˆ‡æ¢ä¸»æ•°æ®é›†çš„æ˜¾ç¤ºçŠ¶æ€
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;

                                // åŒæ—¶åˆ‡æ¢ç›¸å…³çš„å‚è€ƒçº¿æ•°æ®é›†
                                for (let i = customerTypeIndicators.length; i < chart.data.datasets.length; i++) {
                                    const refMeta = chart.getDatasetMeta(i);
                                    const refDataset = chart.data.datasets[i];
                                    // å‚è€ƒçº¿è·Ÿéšå¯¹åº”çš„ä¸»æ•°æ®é›†çš„çŠ¶æ€
                                    if (refDataset.datasetIndexKey === 'reference' && refDataset.mainDatasetIndex === index) {
                                        refMeta.hidden = meta.hidden;
                                    }
                                }

                                chart.update();
                            }
                        },
                        tooltip: {
                            filter: function(tooltipItem) {
                                // åªæ˜¾ç¤ºå®é™…æ•°æ®ï¼Œéšè—å‚è€ƒçº¿
                                return tooltipItem.datasetIndex < customerTypeIndicators.length;
                            },
                            callbacks: {
                                label: function(context) {
                                    const datasetLabel = context.dataset.label || '';
                                    return `${datasetLabel}: ${formatValue(context.parsed.y, 1)}äºº`;
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // åªæ˜¾ç¤ºå®é™…æ•°æ®é›†çš„æ ‡ç­¾ï¼Œä¸æ˜¾ç¤ºå‚è€ƒçº¿
                                return context.datasetIndex < customerTypeIndicators.length;
                            },
                            color: function(context) {
                                return context.dataset.borderColor;
                            },
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: function(context) {
                                return context.dataset.borderColor;
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                return formatValue(value, 1) + 'äºº';
                            },
                            align: function(context) {
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                const y = dataset.data[dataIndex];
                                const scaledY = chart.scales.y.getPixelForValue(y);

                                // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸ŠåŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                                if (scaledY < chartArea.top + 50) {
                                    return 'bottom';
                                }

                                // æ£€æŸ¥ç›¸é‚»æ•°æ®ç‚¹çš„å€¼ï¼Œé¿å…é‡å 
                                const prevY = dataIndex > 0 ? dataset.data[dataIndex - 1] : null;
                                const nextY = dataIndex < dataset.data.length - 1 ? dataset.data[dataIndex + 1] : null;

                                // å¦‚æœä¸ç›¸é‚»ç‚¹å€¼æ¥è¿‘ï¼Œäº¤æ›¿æ˜¾ç¤ºä½ç½®
                                if (prevY && Math.abs(y - prevY) < (chart.scales.y.max - chart.scales.y.min) * 0.08) {
                                    return dataIndex % 2 === 0 ? 'top' : 'bottom';
                                }

                                return 'top';
                            },
                            offset: 8
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'äººæ•°',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + 'äºº';
                                },
                                font: {
                                    size: 11
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'å˜åŒ–é€Ÿåº¦ (%)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è®¾ç½®åˆç†çš„èŒƒå›´
                            min: -100,
                            max: 100
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });

            // ä¸ºæ¯ä¸ªæ•°æ®é›†æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡
            customerTypeIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                setTimeout(() => {
                    addAnalysisIndicators(charts.customerTypeChart, values, 1, 'äºº', storeData[0]['é—¨åº—'], index);
                }, 100);
            });
        }

        // åˆ›å»ºå•ä¸ªæŒ‡æ ‡å›¾è¡¨
        function createIndicatorChart(container, storeData, indicator, chartId) {
            // æå–é—¨åº—åç§°
            const storeName = storeData.length > 0 ? storeData[0]['é—¨åº—'] : currentStore;
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';

            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);

            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            const values = storeData.map(item => parseValue(item[indicator.key]));
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
            const max = Math.max(...values);
            const min = Math.min(...values);

            // ä¸ºè¥æ”¶å’Œç¡®æ”¶å›¾è¡¨ä½¿ç”¨ä¸åŒé¢œè‰²
            const borderColor = indicator.key === 'æ€»è¥æ”¶' ? 'rgb(102, 126, 234)' :
                             indicator.key === 'ç¡®è®¤æ”¶å…¥' ? 'rgb(255, 99, 132)' : 'rgb(102, 126, 234)';
            const backgroundColor = indicator.key === 'æ€»è¥æ”¶' ? 'rgba(102, 126, 234, 0.1)' :
                                   indicator.key === 'ç¡®è®¤æ”¶å…¥' ? 'rgba(255, 99, 132, 0.1)' : 'rgba(102, 126, 234, 0.1)';

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${indicator.label}</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="${chartId}"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            datasets = [{
                label: indicator.label,
                data: values,
                borderColor: borderColor,
                backgroundColor: backgroundColor,
                borderWidth: 3,
                pointRadius: 5,
                pointBackgroundColor: borderColor,
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                tension: 0.2,
                fill: true
            }];

            // åˆ›å»ºå›¾è¡¨ - åœ¨ä¸¤ä¸ªåˆ†æ”¯ä¹‹å¤–å®šä¹‰ctx
            const ctx = document.getElementById(chartId).getContext('2d');

            charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                        axis: 'x', // å¯ç”¨Xè½´è·Ÿè¸ª
                    },
                    // æ·»åŠ XYè·Ÿè¸ªçº¿é…ç½®
                    plugins: {
                        legend: {
                            display: false, // æ‰€æœ‰å›¾è¡¨éƒ½ä¸æ˜¾ç¤ºå›¾ä¾‹
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            enabled: true, // å¯ç”¨tooltipä»¥æ”¯æŒåå­—çº¿ï¼Œä½†åªæ˜¾ç¤ºå¿…è¦ä¿¡æ¯
                            intersect: false,
                            mode: 'index',
                            backgroundColor: 'rgba(0, 0, 0, 0)',
                            titleColor: 'transparent',
                            bodyColor: 'transparent',
                            borderColor: 'transparent',
                            displayColors: false,
                            callbacks: {
                                title: () => '',
                                label: () => ''
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // æ˜¾ç¤ºæ‰€æœ‰æ•°æ®æ ‡ç­¾ï¼Œä½†ä½¿ç”¨æ›´å°çš„å­—ä½“å’Œæ›´æ™ºèƒ½çš„ä½ç½®
                                return true;
                            },
                            color: '#333',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: 'rgba(0, 0, 0, 0.1)',
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                // å®é™…æ•°æ®ç‚¹å¸¦å•ä½
                                return formatValue(value, indicator.scale) + indicator.unit;
                            },
                            align: function(context) {
                                // æ›´æ™ºèƒ½çš„æ ‡ç­¾ä½ç½®è°ƒæ•´ - é˜²æ­¢é‡å 
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                const y = dataset.data[dataIndex];
                                const scaledY = chart.scales.y.getPixelForValue(y);

                                // è·å–å›¾è¡¨é«˜åº¦
                                const chartHeight = chartArea.bottom - chartArea.top;

                                // ç‰¹æ®Šå¤„ç†ï¼šå½“æ•°æ®ç‚¹è¾ƒå¤šæ—¶ä½¿ç”¨æ›´ç´§å‡‘çš„å¸ƒå±€
                                const isDenseChart = dataset.data.length > 10;

                                if (isDenseChart) {
                                    // å¯¹äºè¥æ”¶å›¾è¡¨ï¼Œä½¿ç”¨æ›´ç´§å‡‘çš„å¸ƒå±€
                                    // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸ŠåŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                                    if (scaledY < chartArea.top + chartHeight * 0.25) {
                                        return 'bottom';
                                    }
                                    // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸‹åŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸Šæ–¹
                                    if (scaledY > chartArea.bottom - chartHeight * 0.25) {
                                        return 'top';
                                    }
                                } else {
                                    // å…¶ä»–å›¾è¡¨ä½¿ç”¨æ ‡å‡†é€»è¾‘
                                    if (scaledY < chartArea.top + chartHeight * 0.3) {
                                        return 'bottom';
                                    }
                                    if (scaledY > chartArea.bottom - chartHeight * 0.3) {
                                        return 'top';
                                    }
                                }

                                // æ£€æŸ¥ç›¸é‚»æ•°æ®ç‚¹çš„å€¼ï¼Œé¿å…é‡å 
                                const prevY = dataIndex > 0 ? dataset.data[dataIndex - 1] : null;
                                const nextY = dataIndex < dataset.data.length - 1 ? dataset.data[dataIndex + 1] : null;
                                const threshold = isDenseChart ?
                                    (chart.scales.y.max - chart.scales.y.min) * 0.05 : // å¯†é›†å›¾è¡¨ä½¿ç”¨æ›´å°çš„é˜ˆå€¼
                                    (chart.scales.y.max - chart.scales.y.min) * 0.06;

                                // å¦‚æœä¸ç›¸é‚»ç‚¹å€¼æ¥è¿‘ï¼Œäº¤æ›¿æ˜¾ç¤ºä½ç½®
                                if (prevY && Math.abs(y - prevY) < threshold) {
                                    return dataIndex % 2 === 0 ? 'top' : 'bottom';
                                }

                                if (nextY && Math.abs(y - nextY) < threshold) {
                                    return dataIndex % 2 === 0 ? 'bottom' : 'top';
                                }

                                // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ•°æ®ç‚¹éå¸¸å¯†é›†ï¼Œä½¿ç”¨æ›´ç´§å‡‘çš„å¸ƒå±€
                                if (isDenseChart && dataset.data.length > 10) {
                                    // ä½¿ç”¨æ›´æ™ºèƒ½çš„äº¤æ›¿é€»è¾‘
                                    const density = dataset.data.length / (chartArea.width / 50); // æ¯50åƒç´ çš„å¯†åº¦
                                    if (density > 0.5) {
                                        return dataIndex % 3 === 0 ? 'top' : (dataIndex % 3 === 1 ? 'bottom' : 'top');
                                    }
                                }

                                // é»˜è®¤æ˜¾ç¤ºåœ¨ä¸Šæ–¹
                                return 'top';
                            },
                            offset: 1, // å‡å°‘åç§»é‡ï¼Œé¿å…é—´è·è¿‡å¤§
                            clamp: true, // é˜²æ­¢æ ‡ç­¾è¶…å‡ºcanvasè¾¹ç•Œ
                            // æ—‹è½¬æ ‡ç­¾ä»¥èŠ‚çœç©ºé—´
                            rotation: function(context) {
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const availableWidth = chartArea.width / context.dataset.data.length;

                                // å¦‚æœå¯ç”¨å®½åº¦å¾ˆå°ï¼Œç¨å¾®æ—‹è½¬æ ‡ç­¾
                                if (availableWidth < 40) {
                                    return -10; // è½»å¾®æ—‹è½¬-10åº¦
                                }
                                return 0; // æ°´å¹³æ˜¾ç¤º
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: indicator.key.includes('è½¬åŒ–ç‡'),
                            // å¯¹äºäººå‡æœåŠ¡æ—¶é•¿ï¼Œè®¾ç½®æ›´ç´§å‡‘çš„Yè½´èŒƒå›´ä»¥çªå‡ºè¶‹åŠ¿
                            min: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 1.2 : undefined,
                            max: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 1.7 : undefined,
                            ticks: {
                                callback: function(value) {
                                    return formatValue(value, indicator.scale) + indicator.unit;
                                },
                                // å¯¹äºäººå‡æœåŠ¡æ—¶é•¿ï¼Œè®¾ç½®0.1çš„æ­¥é•¿ä»¥æ˜¾ç¤ºç»†å¾®å˜åŒ–
                                stepSize: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 0.1 : undefined,
                                // ç¡®ä¿æ˜¾ç¤ºå°æ•°ä½
                                precision: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 1 : undefined
                            },
                            grid: {
                                display: false
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'å˜åŒ–é€Ÿåº¦ (%)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è®¾ç½®åˆç†çš„èŒƒå›´
                            min: -100,
                            max: 100
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            // æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡ï¼ˆ3ä¸ªæœˆç§»åŠ¨å¹³å‡å’Œå˜åŒ–é€Ÿåº¦ï¼‰
            setTimeout(() => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                addAnalysisIndicators(charts[chartId], values, indicator.scale, indicator.unit, storeName);

                // ä¸ºè¥æ”¶å’Œç¡®æ”¶å›¾è¡¨æ·»åŠ hoveräº‹ä»¶ç›‘å¬å’Œåå­—çº¿
                if (indicator.key === 'æ€»è¥æ”¶' || indicator.key === 'ç¡®è®¤æ”¶å…¥') {
                    const chart = charts[chartId];
                    let crosshairCanvas = null;

                    // åˆ›å»ºåå­—çº¿ç”»å¸ƒ
                    function createCrosshairCanvas() {
                        crosshairCanvas = document.createElement('canvas');
                        crosshairCanvas.style.position = 'absolute';
                        crosshairCanvas.style.top = '0';
                        crosshairCanvas.style.left = '0';
                        crosshairCanvas.style.pointerEvents = 'none';
                        crosshairCanvas.style.zIndex = '1000';

                        const canvasRect = chart.canvas.getBoundingClientRect();
                        crosshairCanvas.width = canvasRect.width;
                        crosshairCanvas.height = canvasRect.height;

                        chart.canvas.parentElement.style.position = 'relative';
                        chart.canvas.parentElement.appendChild(crosshairCanvas);
                    }

                    // ç»˜åˆ¶åå­—çº¿
                    function drawCrosshair(mouseX, mouseY) {
                        if (!crosshairCanvas) return;

                        const ctx = crosshairCanvas.getContext('2d');
                        const canvasRect = chart.canvas.getBoundingClientRect();

                        // æ¸…é™¤ç”»å¸ƒ
                        ctx.clearRect(0, 0, crosshairCanvas.width, crosshairCanvas.height);

                        // è·å–å›¾è¡¨åŒºåŸŸ
                        const chartArea = chart.chartArea;
                        const scaleX = crosshairCanvas.width / (canvasRect.width);
                        const scaleY = crosshairCanvas.height / (canvasRect.height);

                        const chartLeft = chartArea.left * scaleX;
                        const chartRight = chartArea.right * scaleX;
                        const chartTop = chartArea.top * scaleY;
                        const chartBottom = chartArea.bottom * scaleY;

                        ctx.save();
                        ctx.strokeStyle = 'rgba(128, 128, 128, 0.9)'; // æ·±ç°è‰²
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 4]);

                        // ç»˜åˆ¶å‚ç›´çº¿
                        ctx.beginPath();
                        ctx.moveTo(mouseX, chartTop);
                        ctx.lineTo(mouseX, chartBottom);
                        ctx.stroke();

                        // ç»˜åˆ¶æ°´å¹³çº¿
                        ctx.beginPath();
                        ctx.moveTo(chartLeft, mouseY);
                        ctx.lineTo(chartRight, mouseY);
                        ctx.stroke();

                        ctx.restore();
                    }

                    // æ¸…é™¤åå­—çº¿
                    function clearCrosshair() {
                        if (crosshairCanvas) {
                            const ctx = crosshairCanvas.getContext('2d');
                            ctx.clearRect(0, 0, crosshairCanvas.width, crosshairCanvas.height);
                        }
                    }

                    // å»¶è¿Ÿåˆ›å»ºåå­—çº¿ç”»å¸ƒï¼Œç¡®ä¿å›¾è¡¨å·²å®Œå…¨æ¸²æŸ“
                    setTimeout(() => {
                        createCrosshairCanvas();
                    }, 200);

                    // é¼ æ ‡è¿›å…¥äº‹ä»¶
                    chart.canvas.addEventListener('mousemove', function(event) {
                        const rect = chart.canvas.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;

                        const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                        const dataIndex = Math.round(dataX);

                        // ç»˜åˆ¶åå­—çº¿
                        drawCrosshair(x, y);

                        if (dataIndex >= 0 && dataIndex < storeData.length) {
                            // æ›´æ–°å¯¹åº”çš„ç°é‡‘æµè¡¨æ ¼
                            updateCashFlowTable(storeData, indicator, dataIndex);

                            // æ˜¾ç¤ºæ‚¬æµ®ä¿¡æ¯æ¡†
                            showHoverInfo(event, storeData, dataIndex, indicator);
                        }
                    });

                    // é¼ æ ‡ç¦»å¼€äº‹ä»¶ - æ¢å¤é»˜è®¤æ˜¾ç¤º
                    chart.canvas.addEventListener('mouseleave', function() {
                        // æ¸…é™¤åå­—çº¿
                        clearCrosshair();

                        // æ¢å¤é»˜è®¤çš„ç°é‡‘æµè¡¨æ ¼ï¼ˆæœ€æ–°æœˆä»½ï¼‰
                        setTimeout(() => {
                            const latestIndex = storeData.length - 1;
                            updateCashFlowTable(storeData, indicator, latestIndex);
                        }, 100); // ç¨å¾®å»¶è¿Ÿï¼Œé¿å…é—ªçƒ

                        // éšè—æ‚¬æµ®ä¿¡æ¯æ¡†
                        hideHoverInfo();
                    });
                }
            }, 150);
        }

        // è½¬åŒ–ç‡ç›®æ ‡å€¼é…ç½®
        function getTargetValues(conversionType) {
            const targets = {
                'A': { pass: 20, excellent: 30 },
                'B': { pass: 50, excellent: 80 },
                'C': { pass: 50, excellent: 80 }, // ä¸Bç±»ç›¸åŒ
                'D': { pass: null, excellent: null } // Dç±»ä¸æ˜¾ç¤ºç›®æ ‡çº¿
            };
            return targets[conversionType] || { pass: null, excellent: null };
        }

        // åˆ›å»ºè½¬åŒ–ç±»æŒ‡æ ‡å›¾è¡¨
        function createConversionChart(container, storeData, indicator, chartId) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container special-chart';

            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);
            const denomData = storeData.map(item => parseValue(item[indicator.denomKey])); // è½¬åŒ–åˆ†æ¯
            const numData = storeData.map(item => parseValue(item[indicator.numKey]));     // è½¬åŒ–æ•°
            const rateData = storeData.map(item => parseValue(item[indicator.rateKey]));     // è½¬åŒ–ç‡

            // è®¡ç®—è½¬åŒ–ç‡çš„ç»Ÿè®¡
            const avgRate = rateData.reduce((sum, val) => sum + val, 0) / rateData.length;
            const maxRate = Math.max(...rateData);
            const minRate = Math.min(...rateData);

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${indicator.type}ç±»è½¬åŒ–åˆ†æ</div>
                        <div class="chart-subtitle">è½¬åŒ–ç‡å¹³å‡: ${avgRate.toFixed(1)}% | æœ€å¤§: ${maxRate.toFixed(1)}% | æœ€å°: ${minRate.toFixed(1)}%</div>
                    </div>
                </div>

                <!-- ä¸ŠåŠéƒ¨åˆ†ï¼šè½¬åŒ–å¯¹æ¯”å›¾è¡¨ï¼ˆæŸ±çŠ¶å›¾+æŠ˜çº¿å›¾ï¼‰ -->
                <div class="chart-subsection">
                    <div class="chart-wrapper-small">
                        <canvas id="${chartId}_conversion"></canvas>
                    </div>
                </div>

                <!-- ä¸‹åŠéƒ¨åˆ†ï¼šè½¬åŒ–ç‡è¶‹åŠ¿å›¾è¡¨ -->
                <div class="chart-subsection">
                    <div class="chart-wrapper-small rate-chart">
                        <canvas id="${chartId}_rate"></canvas>
                    </div>
                </div>
            `;

            container.appendChild(chartContainer);

            // åˆ›å»ºä¸ŠåŠéƒ¨åˆ†å›¾è¡¨ï¼šè½¬åŒ–æ•°ï¼ˆæŠ˜çº¿å›¾ï¼‰+ è½¬åŒ–åˆ†æ¯ï¼ˆæŸ±çŠ¶å›¾ï¼‰
            const ctxConversion = document.getElementById(`${chartId}_conversion`).getContext('2d');
            charts[`${chartId}_conversion`] = new Chart(ctxConversion, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        // è½¬åŒ–åˆ†æ¯ - æŸ±çŠ¶å›¾ï¼ˆåº•å±‚ï¼‰
                        {
                            label: 'è½¬åŒ–åˆ†æ¯',
                            data: denomData,
                            backgroundColor: '#87CEEB', // å¤©è“è‰²
                            borderColor: '#4682B4',      // é’¢è“è‰²
                            borderWidth: 1,
                            order: 2,
                            yAxisID: 'y'
                        },
                        // è½¬åŒ–æ•° - æŠ˜çº¿å›¾ï¼ˆé¡¶å±‚ï¼‰
                        {
                            label: 'è½¬åŒ–æ•°',
                            data: numData,
                            borderColor: indicator.color,
                            backgroundColor: indicator.color + '20',
                            borderWidth: 3,
                            fill: false,
                            type: 'line',
                            tension: 0.3,
                            pointRadius: 5,
                            pointBackgroundColor: indicator.color,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            pointHoverRadius: 7,
                            order: 1,
                            yAxisID: 'y1' // ä½¿ç”¨å³ä¾§Yè½´
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    if (context.datasetIndex === 0) {
                                        return `è½¬åŒ–åˆ†æ¯: ${context.parsed.y}äºº`;
                                    } else {
                                        return [
                                            `è½¬åŒ–æ•°: ${context.parsed.y}äºº`,
                                            `è½¬åŒ–ç‡: ${rateData[dataIndex].toFixed(1)}%`
                                        ];
                                    }
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // æ˜¾ç¤ºæ‰€æœ‰æ ‡ç­¾ï¼ŒåŒ…æ‹¬0å€¼ï¼Œä½†ä¼šè°ƒæ•´ä½ç½®é¿å…é®æŒ¡
                                return true;
                            },
                            color: function(context) {
                                // è½¬åŒ–åˆ†æ¯ç”¨è“è‰²ï¼Œè½¬åŒ–æ•°ç”¨å½©è‰²
                                return context.datasetIndex === 0 ? '#4682B4' : indicator.color;
                            },
                            font: {
                                size: 8,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: function(context) {
                                return context.datasetIndex === 0 ? '#4682B4' : indicator.color;
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                // ç¡®ä¿äººæ•°æ˜¾ç¤ºä¸ºæ•´æ•°ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
                                return Math.round(value) + 'äºº';
                            },
                            anchor: 'end',
                            align: function(context) {
                                const dataIndex = context.dataIndex;
                                const denomValue = denomData[dataIndex]; // è½¬åŒ–åˆ†æ¯
                                const numValue = numData[dataIndex];    // è½¬åŒ–æ•°
                                const currentDataset = context.dataset.data[dataIndex];

                                // è®¡ç®—æ•°å€¼æ¥è¿‘ç¨‹åº¦ï¼ˆ30%ä»¥å†…æˆ–ç»å¯¹å€¼å·®å°äº3äººè®¤ä¸ºæ¥è¿‘ï¼‰
                                const isClose = Math.abs(denomValue - numValue) / Math.max(denomValue, numValue) < 0.3 ||
                                               Math.abs(denomValue - numValue) < 3;

                                if (context.datasetIndex === 0) { // è½¬åŒ–åˆ†æ¯ï¼ˆæŸ±çŠ¶å›¾ï¼‰
                                    if (currentDataset === 0) {
                                        return 'bottom'; // 0å€¼æ˜¾ç¤ºåœ¨æŸ±åº•ï¼Œé¿å…è¦†ç›–æœˆä»½
                                    } else {
                                        return 'top'; // éé›¶å€¼æ˜¾ç¤ºåœ¨æŸ±é¡¶
                                    }
                                } else { // è½¬åŒ–æ•°ï¼ˆæŠ˜çº¿å›¾ï¼‰
                                    if (currentDataset === 0) {
                                        return 'bottom'; // 0å€¼æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸‹æ–¹
                                    } else if (isClose) {
                                        return 'bottom'; // æ•°å€¼æ¥è¿‘æ—¶æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸‹æ–¹ï¼Œé¿å…é‡å 
                                    } else {
                                        return 'top'; // æ•°å€¼ä¸æ¥è¿‘æ—¶æ­£å¸¸æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸Šæ–¹
                                    }
                                }
                            },
                            offset: function(context) {
                                const dataIndex = context.dataIndex;
                                const denomValue = denomData[dataIndex]; // è½¬åŒ–åˆ†æ¯
                                const numValue = numData[dataIndex];    // è½¬åŒ–æ•°
                                const currentDataset = context.dataset.data[dataIndex];

                                // è®¡ç®—æ•°å€¼æ¥è¿‘ç¨‹åº¦ï¼ˆ30%ä»¥å†…æˆ–ç»å¯¹å€¼å·®å°äº3äººè®¤ä¸ºæ¥è¿‘ï¼‰
                                const isClose = Math.abs(denomValue - numValue) / Math.max(denomValue, numValue) < 0.3 ||
                                               Math.abs(denomValue - numValue) < 3;

                                if (context.datasetIndex === 0) { // è½¬åŒ–åˆ†æ¯
                                    if (currentDataset === 0) {
                                        return -3; // 0å€¼æ˜¾ç¤ºåœ¨æŸ±åº•ä¸‹æ–¹ï¼Œé¿å…è¦†ç›–æœˆä»½
                                    } else {
                                        return 2; // éé›¶å€¼æ˜¾ç¤ºåœ¨æŸ±é¡¶ä¸Šæ–¹ä¸€ç‚¹
                                    }
                                } else { // è½¬åŒ–æ•°
                                    if (currentDataset === 0) {
                                        return 8; // 0å€¼æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸‹æ–¹
                                    } else if (isClose) {
                                        return 10; // æ•°å€¼æ¥è¿‘æ—¶ï¼Œåœ¨æŠ˜çº¿ä¸‹æ–¹æ›´è¿œå¤„ï¼Œå®Œå…¨é”™å¼€
                                    } else {
                                        return 5; // æ•°å€¼ä¸æ¥è¿‘æ—¶ï¼Œåœ¨æŠ˜çº¿ä¸Šæ–¹æ­£å¸¸è·ç¦»
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'è½¬åŒ–åˆ†æ¯ï¼ˆäººï¼‰',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return Math.round(value) + 'äºº';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è°ƒæ•´å·¦ä¾§Yè½´èŒƒå›´ï¼Œç»™æ•°å€¼ç•™æ›´å¤šç©ºé—´
                            max: Math.max(...denomData) * 1.3
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'è½¬åŒ–æ•°ï¼ˆäººï¼‰',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return Math.round(value) + 'äºº';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // é’ˆå¯¹ä¸åŒè½¬åŒ–ç±»å‹è°ƒæ•´å³ä¾§Yè½´èŒƒå›´
                            max: function() {
                                const numMax = Math.max(...numData);
                                const denomMax = Math.max(...denomData);

                                // å¯¹äºä¸åŒè½¬åŒ–ç±»å‹ï¼Œè®¾ç½®ä¸åŒçš„Yè½´èŒƒå›´
                                if (indicator.type === 'A') {
                                    // Aç±»ï¼šå³ä¾§Yè½´èŒƒå›´å›ºå®šä¸º0-15
                                    return 15;
                                } else if (indicator.type === 'D') {
                                    // Dç±»ï¼šå³ä¾§Yè½´èŒƒå›´å›ºå®šä¸º0-25ï¼Œè®©åˆ†å­è¶‹åŠ¿æ›´æ˜æ˜¾
                                    return 25;
                                } else {
                                    // Bç±»å’ŒCç±»ï¼šä¿æŒåŸæœ‰é€»è¾‘
                                    return Math.max(numMax, denomMax) * 1.2;
                                }
                            }()
                        }
                    }
                }
            });

            // åˆ›å»ºä¸‹åŠéƒ¨åˆ†å›¾è¡¨ï¼šè½¬åŒ–ç‡è¶‹åŠ¿
            const ctxRate = document.getElementById(`${chartId}_rate`).getContext('2d');

            // è·å–ç›®æ ‡å€¼
            const targetValues = getTargetValues(indicator.type);

            // åŠ¨æ€æ„å»ºæ•°æ®é›†
            const datasets = [
                {
                    label: 'è½¬åŒ–ç‡',
                    data: rateData,
                    borderColor: '#ff6b6b',
                    backgroundColor: '#ff6b6b20',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.3,
                    pointRadius: 5,
                    pointBackgroundColor: '#ff6b6b',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 7,
                    order: 1
                }
            ];

            // åªæœ‰å½“æœ‰ç›®æ ‡å€¼æ—¶æ‰æ·»åŠ å‚è€ƒçº¿
            if (targetValues.excellent !== null && targetValues.excellent > 0) {
                datasets.push({
                    label: 'ä¼˜ç§€å€¼',
                    data: new Array(rateData.length).fill(targetValues.excellent),
                    borderColor: '#27ae60',
                    borderWidth: 2,
                    borderDash: [8, 4],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                    order: 2,
                    datalabels: {
                        display: function(context) {
                            return context.dataIndex === rateData.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                        },
                        align: 'left',
                        anchor: 'center',
                        offset: 8,
                        color: '#27ae60',
                        font: {
                            size: 10,
                            weight: 'bold'
                        },
                        formatter: function() {
                            return `ä¼˜ç§€: ${targetValues.excellent}%`;
                        }
                    }
                });
            }

            if (targetValues.pass !== null && targetValues.pass > 0) {
                datasets.push({
                    label: 'åŠæ ¼å€¼',
                    data: new Array(rateData.length).fill(targetValues.pass),
                    borderColor: '#f39c12',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                    order: 2,
                    datalabels: {
                        display: function(context) {
                            return context.dataIndex === rateData.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                        },
                        align: 'left',
                        anchor: 'center',
                        offset: 8,
                        color: '#f39c12',
                        font: {
                            size: 10,
                            weight: 'bold'
                        },
                        formatter: function() {
                            return `åŠæ ¼: ${targetValues.pass}%`;
                        }
                    }
                });
            }

            charts[`${chartId}_rate`] = new Chart(ctxRate, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    return [
                                        `è½¬åŒ–ç‡: ${context.parsed.y.toFixed(1)}%`,
                                        `è½¬åŒ–æ•°: ${numData[dataIndex]}äºº / åˆ†æ¯: ${denomData[dataIndex]}äºº`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: '#ff6b6b',
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                return value.toFixed(1) + '%';
                            },
                            anchor: 'end',
                            align: 'top',
                            offset: 3
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'è½¬åŒ–ç‡ (%)',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            max: Math.max(targetValues.excellent, Math.max(...rateData)) * 1.2
                        }
                    }
                }
            });
        }


        // æ·»åŠ åªæœ‰å¹³å‡å€¼çš„å‚è€ƒçº¿
        function addSimpleAverageLine(chart, values, color, label, datasetIndex) {
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;

            // ä¿®å¤æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
            const fixedAvg = (Math.abs(avg - Math.round(avg)) < 0.000001) ? Math.round(avg) : avg;

            chart.data.datasets.push({
                label: `${label}å¹³å‡`,
                data: new Array(values.length).fill(fixedAvg),
                borderColor: color,
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                datalabels: {
                    display: function(context) {
                        return context.dataIndex === values.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                    },
                    align: 'left',
                    anchor: 'center',
                    offset: function(context) {
                        // æ™ºèƒ½è°ƒæ•´åç§»é‡ï¼Œé¿å…é‡å 
                        const datasetIndex = context.datasetIndex;
                        const baseOffset = 8;

                        // æ ¹æ®æ•°æ®é›†æ•°é‡å’Œç´¢å¼•åŠ¨æ€è°ƒæ•´é—´è·
                        const smartSpacing = Math.max(12, Math.min(18, 8 + datasetIndex * 10));

                        // å¦‚æœæ˜¯å¤šä¸ªæ•°æ®é›†ï¼Œå‡å°‘é—´è·é¿å…è¿‡åº¦åˆ†æ•£
                        return baseOffset + (datasetIndex * smartSpacing);
                    },
                    color: color,
                    font: {
                        size: 10,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                    borderColor: color,
                    borderWidth: 1,
                    borderRadius: 3,
                    padding: 2,
                    formatter: function() {
                        return `å¹³å‡: ${fixedAvg}äºº`;
                    }
                }
            });

            chart.update();
        }

        // ä¸ºæ•°æ®é›†æ·»åŠ å‚è€ƒçº¿ï¼ˆåªæ˜¾ç¤ºå¹³å‡å€¼ï¼‰
        // æ·»åŠ å‚è€ƒçº¿ï¼Œä½¿ç”¨æ•°æ®é›†çš„é¢œè‰²
        function addReferenceLinesForDataset(chart, values, scale, unit, storeName, datasetCount, lineColor = '#27ae60') {
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;

            // ä¿®å¤å°æ•°ç‚¹æ˜¾ç¤ºé—®é¢˜ï¼Œä¿ç•™1ä½å°æ•°
            const fixedAvg = Math.round(avg * 10) / 10;

            chart.data.datasets.push({
                label: 'å¹³å‡',
                data: new Array(values.length).fill(fixedAvg),
                borderColor: lineColor,
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                // æ·»åŠ è¿™ä¸ªå±æ€§æ¥éšè—tooltip
                parsing: {
                    yAxisKey: 'y'
                },
                // éšè—åœ¨tooltipä¸­
                order: 99,
                datalabels: {
                    display: function(context) {
                        return context.dataIndex === values.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                    },
                    align: 'left',
                    anchor: 'center',
                    offset: function(context) {
                        // æ™ºèƒ½è°ƒæ•´åç§»é‡ï¼Œé¿å…é‡å 
                        const datasetIndex = context.datasetIndex;
                        const baseOffset = 8;

                        // æ ¹æ®æ•°æ®é›†æ•°é‡å’Œç´¢å¼•åŠ¨æ€è°ƒæ•´é—´è·
                        const smartSpacing = Math.max(12, Math.min(18, 8 + datasetIndex * 10));

                        // å¦‚æœæ˜¯å¤šä¸ªæ•°æ®é›†ï¼Œå‡å°‘é—´è·é¿å…è¿‡åº¦åˆ†æ•£
                        return baseOffset + (datasetIndex * smartSpacing);
                    },
                    color: lineColor,
                    font: {
                        size: 10,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: lineColor,
                    borderWidth: 1,
                    borderRadius: 3,
                    padding: 2,
                    formatter: function() {
                        return `å¹³å‡: ${fixedAvg}äºº`;
                    }
                }
            });

            chart.update();
        }

        // è®¡ç®—3ä¸ªæœˆç§»åŠ¨å¹³å‡å€¼
        function calculateMovingAverage(values, windowSize = 3) {
            const result = [];
            for (let i = 0; i < values.length; i++) {
                if (i < windowSize - 1) {
                    result.push(null); // å‰å‡ ä¸ªæœˆæ²¡æœ‰è¶³å¤Ÿæ•°æ®
                } else {
                    const sum = values.slice(i - windowSize + 1, i + 1).reduce((a, b) => a + b, 0);
                    result.push(sum / windowSize);
                }
            }
            return result;
        }

        // è®¡ç®—å˜åŒ–é€Ÿåº¦ï¼ˆ3ä¸ªæœˆç§»åŠ¨å¹³å‡çš„æ–œç‡ï¼‰
        function calculateChangeRate(values, windowSize = 3) {
            const movingAvg = calculateMovingAverage(values, windowSize);
            const result = [];

            for (let i = 0; i < movingAvg.length; i++) {
                if (i < windowSize || movingAvg[i] === null || movingAvg[i - windowSize] === null) {
                    result.push(null);
                } else {
                    const change = movingAvg[i] - movingAvg[i - windowSize];
                    const rate = (change / movingAvg[i - windowSize]) * 100;
                    result.push(rate);
                }
            }
            return result;
        }

        // æ·»åŠ è‡ªå®šä¹‰å‚è€ƒçº¿åˆ°å›¾è¡¨
        function addCustomReferenceLines(chart, indicatorKey, storeName) {
            const lines = referenceLineManager.getLines(indicatorKey, storeName);
            const selectedLineId = referenceLineManager.data[storeName]?.[indicatorKey]?.selectedLineId;

            lines.forEach(line => {
                const isSelected = line.id === selectedLineId;
                const lineWidth = isSelected ? 3 : 2;
                const lineOpacity = isSelected ? 1 : 0.7;

                // åˆ›å»ºå‚è€ƒçº¿æ•°æ®é›†
                const lineDataset = {
                    label: line.name,
                    data: new Array(chart.data.labels.length).fill(line.value),
                    borderColor: line.color,
                    backgroundColor: 'transparent',
                    borderWidth: lineWidth,
                    borderDash: isSelected ? [10, 5] : [8, 4],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    hiddenInLegend: false, // åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                    order: 3, // ç¡®ä¿çº¿æ¡åœ¨æœ€ä¸Šå±‚
                    isReferenceLine: true,
                    referenceLineId: line.id
                };

                // æ·»åŠ æ•°æ®æ ‡ç­¾ï¼ˆç¡®ä¿æ‰€æœ‰å‚è€ƒçº¿éƒ½æ˜¾ç¤ºæ ‡ç­¾ï¼‰
                lineDataset.datalabels = {
                    display: function(context) {
                        // åªåœ¨ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæ•°æ®ç‚¹æ˜¾ç¤ºæ ‡ç­¾
                        return context.dataIndex === 0 || context.dataIndex === chart.data.labels.length - 1;
                    },
                    color: line.color,
                    font: {
                        size: isSelected ? 10 : 9,
                        weight: isSelected ? 'bold' : 'normal'
                    },
                    backgroundColor: isSelected ? 'rgba(255, 255, 255, 0.95)' : 'rgba(255, 255, 255, 0.8)',
                    borderRadius: isSelected ? 4 : 3,
                    padding: isSelected ? 4 : 2,
                    formatter: (value) => {
                        const formattedValue = formatValue(line.value / 10000, 1);
                        return `${line.name} (${formattedValue}ä¸‡)`;
                    },
                    anchor: 'end',
                    align: function(context) {
                        // é€‰ä¸­çš„çº¿æ˜¾ç¤ºåœ¨ä¸Šæ–¹ï¼Œå…¶ä»–çº¿æ˜¾ç¤ºåœ¨ä¸‹æ–¹é¿å…é‡å 
                        return isSelected ? 'top' : 'bottom';
                    },
                    offset: isSelected ? 8 : 4
                };

                chart.data.datasets.push(lineDataset);
            });
        }

        // æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡åˆ°å›¾è¡¨
        function addAnalysisIndicators(chart, values, scale, unit, storeName = null, mainDatasetIndex = null) {
            // è·å–å›¾è¡¨æ ‡ç­¾ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºè¥æ”¶æˆ–ç¡®æ”¶å›¾è¡¨
            const chartLabel = chart.data.datasets[0].label;
            const isRevenueChart = chartLabel === 'æ€»è¥æ”¶' || chartLabel === 'ç¡®è®¤æ”¶å…¥';

            // è·å–å½“å‰é—¨åº—
            const currentStoreName = storeName || currentStore;

            // ä½¿ç”¨å‚è€ƒçº¿ç®¡ç†ç³»ç»Ÿè·å–å¹³è¡¡ç‚¹
            let breakevenPoint = 0;
            if (chartLabel === 'æ€»è¥æ”¶' || chartLabel === 'ç¡®è®¤æ”¶å…¥') {
                breakevenPoint = referenceLineManager.getBalancePoint(chartLabel, currentStoreName);
            }

            // æ·»åŠ è‡ªå®šä¹‰å‚è€ƒçº¿åˆ°å›¾è¡¨
            if (isRevenueChart) {
                addCustomReferenceLines(chart, chartLabel, currentStoreName);
            }

            // è®¡ç®—3ä¸ªæœˆç§»åŠ¨å¹³å‡
            const movingAvgValues = calculateMovingAverage(values, 3);

            // è®¡ç®—å˜åŒ–é€Ÿåº¦
            const changeRateValues = calculateChangeRate(values, 3);

            // è®¡ç®—ç§»åŠ¨å¹³å‡çº¿çš„æ–œç‡ç™¾åˆ†æ¯”ï¼ˆç›¸å¯¹äºä¸Šæœˆçš„ç™¾åˆ†æ¯”å˜åŒ–ï¼‰
            const movingAvgChangeRates = [];
            for (let i = 1; i < movingAvgValues.length; i++) {
                if (movingAvgValues[i-1] !== null && movingAvgValues[i] !== null && movingAvgValues[i-1] !== 0) {
                    const changeRate = ((movingAvgValues[i] - movingAvgValues[i-1]) / movingAvgValues[i-1]) * 100;
                    movingAvgChangeRates.push(changeRate);
                } else {
                    movingAvgChangeRates.push(null);
                }
            }
            movingAvgChangeRates.unshift(null); // ç¬¬ä¸€ä¸ªæœˆæ²¡æœ‰å˜åŒ–ç‡

            // æ™ºèƒ½æ ‡ç­¾åç§»è®¡ç®— - é¿å…é‡å å’Œé—´è·è¿‡å¤§
            function calculateSmartOffset(context, baseOffset, labelType) {
                const dataIndex = context.dataIndex;
                const chart = context.chart;
                const datasets = chart.data.datasets;

                // è·å–å½“å‰ç‚¹çš„ä½ç½®
                const datasetIndex = context.datasetIndex;
                const meta = chart.getDatasetMeta(datasetIndex);
                if (!meta || !meta.data[dataIndex]) return baseOffset;

                const point = meta.data[dataIndex];
                const y = point.y;

                // è®¡ç®—åŠ¨æ€åç§»
                let smartOffset = baseOffset;

                if (labelType === 'movingAvg') {
                    // ç§»åŠ¨å¹³å‡æ ‡ç­¾çš„æ™ºèƒ½åç§»
                    if (dataIndex > 0) {
                        const prevValue = movingAvgValues[dataIndex - 1];
                        const currValue = movingAvgValues[dataIndex];

                        // å¦‚æœæ•°å€¼å˜åŒ–å¾ˆå¤§ï¼Œé€‚å½“è°ƒæ•´é—´è·
                        if (prevValue !== null && currValue !== null) {
                            const changePercent = Math.abs((currValue - prevValue) / prevValue);
                            if (changePercent > 0.5) {
                                // å˜åŒ–å¾ˆå¤§æ—¶ï¼Œä¿æŒåŸºç¡€åç§»ï¼Œé¿å…è¿‡åº¦è°ƒæ•´
                                smartOffset = baseOffset;
                            } else if (changePercent < 0.05) {
                                // å˜åŒ–å¾ˆå°æ—¶ï¼Œå¾®è°ƒé¿å…é‡å 
                                smartOffset += 1;
                            }
                        }
                    }

                    // æ£€æŸ¥æ˜¯å¦ä¸ç›¸é‚»æ ‡ç­¾é‡å 
                    if (dataIndex > 0 && dataIndex < movingAvgValues.length - 1) {
                        const prevPoint = meta.data[dataIndex - 1];
                        const nextPoint = meta.data[dataIndex + 1];

                        if (prevPoint && nextPoint) {
                            const prevY = prevPoint.y;
                            const nextY = nextPoint.y;
                            const currentY = y;

                            // å¦‚æœå½“å‰ç‚¹å¤¹åœ¨ä¸¤ä¸ªç›¸é‚»ç‚¹ä¹‹é—´ï¼Œå‡å°‘åç§»
                            if ((currentY > prevY && currentY < nextY) || (currentY < prevY && currentY > nextY)) {
                                if (Math.abs(currentY - prevY) < 15 || Math.abs(currentY - nextY) < 15) {
                                    smartOffset = Math.abs(smartOffset) > 6 ? Math.sign(smartOffset) * 6 : smartOffset;
                                }
                            }
                        }
                    }

                    // é™åˆ¶æœ€å¤§åç§»ï¼Œé¿å…é—´è·è¿‡å¤§
                    if (Math.abs(smartOffset) > 15) {
                        smartOffset = Math.sign(smartOffset) * 15;
                    }

                } else if (labelType === 'slope') {
                    // æ–œç‡æ ‡ç­¾çš„æ™ºèƒ½åç§» - åŸºäºç§»åŠ¨å¹³å‡æ ‡ç­¾çš„ä½ç½®
                    smartOffset = 15; // åŸºç¡€é—´è·ï¼Œæ¯”åŸæ¥ç¨å°

                    // æ ¹æ®æ•°å€¼å¤§å°å¾®è°ƒï¼Œä½†é™åˆ¶èŒƒå›´
                    const value = movingAvgValues[dataIndex];
                    if (value !== null) {
                        if (scale === 10000 && value > 150000) {
                            smartOffset += 2; // å‡å°‘å¢é‡
                        } else if (scale === 1 && value > 100) {
                            smartOffset += 1;
                        }
                    }

                    // é™åˆ¶æ–œç‡æ ‡ç­¾çš„æœ€å¤§åç§»
                    if (Math.abs(smartOffset) > 18) {
                        smartOffset = Math.sign(smartOffset) * 18;
                    }
                }

                return smartOffset;
            }

            // æ·»åŠ 3ä¸ªæœˆç§»åŠ¨å¹³å‡çº¿æ•°å€¼æ ‡ç­¾ï¼ˆç¬¬ä¸€è¡Œï¼‰
            chart.data.datasets.push({
                label: '3ä¸ªæœˆç§»åŠ¨å¹³å‡',
                data: movingAvgValues,
                borderColor: '#27ae60',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true,
                datasetIndexKey: 'reference',
                mainDatasetIndex: mainDatasetIndex,
                datalabels: {
                    display: function(context) {
                        return movingAvgValues[context.dataIndex] !== null;
                    },
                    align: 'top',
                    anchor: 'end',
                    // ç‰¹æ®Šå¤„ç†ï¼šå¯¹äºè¥æ”¶å›¾è¡¨ï¼Œä½¿ç”¨æ›´ç´§å‡‘çš„é”šç‚¹
                    anchor: function(context) {
                        // ç®€åŒ–åˆ¤æ–­ï¼šå½“æ•°æ®ç‚¹è¾ƒå¤šæ—¶ä½¿ç”¨æ›´ç´§å‡‘çš„å¸ƒå±€
                        if (movingAvgValues.length > 10) {
                            return 'center'; // å¯¹äºå¯†é›†çš„å›¾è¡¨ï¼Œä½¿ç”¨ä¸­å¿ƒé”šç‚¹
                        }
                        return 'end';
                    },
                    offset: function(context) {
                        return calculateSmartOffset(context, -8, 'movingAvg'); // å‡å°‘åŸºç¡€åç§»
                    },
                    color: '#27ae60',
                    font: {
                        size: 9,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#27ae60',
                    borderWidth: 1,
                    borderRadius: 3,
                    padding: 2,
                    formatter: function(value, context) {
                        return `${formatValue(value, scale)}${unit}`;
                    }
                }
            });

            // æ·»åŠ ç§»åŠ¨å¹³å‡æ–œç‡æ ‡ç­¾ï¼ˆç¬¬äºŒè¡Œï¼Œå¸¦é¢œè‰²ï¼‰
            chart.data.datasets.push({
                label: 'ç§»åŠ¨å¹³å‡æ–œç‡',
                data: movingAvgValues,
                borderColor: 'transparent',
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true,
                datasetIndexKey: 'reference',
                mainDatasetIndex: mainDatasetIndex,
                datalabels: {
                    display: function(context) {
                        const dataIndex = context.dataIndex;
                        return movingAvgValues[dataIndex] !== null && movingAvgChangeRates[dataIndex] !== null;
                    },
                    align: 'bottom',
                    anchor: 'end',
                    // ç‰¹æ®Šå¤„ç†ï¼šå¯¹äºè¥æ”¶å›¾è¡¨ï¼Œä½¿ç”¨æ›´ç´§å‡‘çš„é”šç‚¹
                    anchor: function(context) {
                        // ç®€åŒ–åˆ¤æ–­ï¼šå½“æ•°æ®ç‚¹è¾ƒå¤šæ—¶ä½¿ç”¨æ›´ç´§å‡‘çš„å¸ƒå±€
                        if (movingAvgValues.length > 10) {
                            return 'center'; // å¯¹äºå¯†é›†çš„å›¾è¡¨ï¼Œä½¿ç”¨ä¸­å¿ƒé”šç‚¹
                        }
                        return 'end';
                    },
                    offset: function(context) {
                        return calculateSmartOffset(context, 12, 'slope'); // å‡å°‘åŸºç¡€é—´è·
                    },
                    color: function(context) {
                        const dataIndex = context.dataIndex;
                        const slopeRate = movingAvgChangeRates[dataIndex];
                        return slopeRate > 0 ? '#e74c3c' : '#27ae60';
                    },
                    font: {
                        size: 8,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: function(context) {
                        const dataIndex = context.dataIndex;
                        const slopeRate = movingAvgChangeRates[dataIndex];
                        return slopeRate > 0 ? '#e74c3c' : '#27ae60';
                    },
                    borderWidth: 1,
                    borderRadius: 2,
                    padding: 1,
                    formatter: function(value, context) {
                        const dataIndex = context.dataIndex;
                        const slopeRate = movingAvgChangeRates[dataIndex];
                        if (slopeRate !== null) {
                            const arrow = slopeRate > 0 ? 'â†—' : 'â†˜';
                            return `${arrow} ${Math.abs(slopeRate).toFixed(1)}%`;
                        }
                        return '';
                    }
                }
            });


            // è®¡ç®—ç§»åŠ¨å¹³å‡çº¿çš„æ–œç‡ï¼ˆè¶‹åŠ¿åˆ¤æ–­ï¼‰
            function calculateMovingAverageSlope(movingAvgValues) {
                const slopes = [];
                for (let i = 1; i < movingAvgValues.length; i++) {
                    if (movingAvgValues[i] !== null && movingAvgValues[i-1] !== null) {
                        // æ–œç‡ = (å½“å‰å€¼ - å‰å€¼) / æ—¶é—´é—´éš”ï¼ˆ1ä¸ªæœˆï¼‰
                        const slope = movingAvgValues[i] - movingAvgValues[i-1];
                        slopes.push(slope);
                    } else {
                        slopes.push(0);
                    }
                }
                slopes.unshift(0); // ç¬¬ä¸€ä¸ªæœˆæ–œç‡ä¸º0
                return slopes;
            }

            // è®¡ç®—ç§»åŠ¨å¹³å‡æ–œç‡
            const movingAvgSlopes = calculateMovingAverageSlope(movingAvgValues);

            // åŸºäºæœ€æ–°ä¸€ä¸ªæœˆçš„ç§»åŠ¨å¹³å‡æ–œç‡åˆ¤æ–­è¶‹åŠ¿
            const latestSlope = movingAvgSlopes[movingAvgSlopes.length - 1];
            const prevSlope = movingAvgSlopes.length > 1 ? movingAvgSlopes[movingAvgSlopes.length - 2] : 0;

            // åˆ¤æ–­è¶‹åŠ¿ï¼ˆè€ƒè™‘æ–œç‡å¤§å°å’Œæ–¹å‘å˜åŒ–ï¼‰
            let trend = '';
            let trendColor = '';

            if (latestSlope > 0) {
                trend = 'â†— ä¸Šå‡';
                trendColor = '#27ae60';
            } else if (latestSlope < 0) {
                trend = 'â†˜ ä¸‹é™';
                trendColor = '#e74c3c';
            } else {
                trend = 'â†’ å¹³ç¨³';
                trendColor = '#f39c12';
            }


            // æ³¨ï¼šåŸæœ‰çš„ç›ˆäºå¹³è¡¡çº¿é€»è¾‘å·²è¢«æ–°çš„å‚è€ƒçº¿ç®¡ç†ç³»ç»Ÿæ›¿ä»£
            // æ–°çš„å‚è€ƒçº¿ç³»ç»Ÿåœ¨ addCustomReferenceLines å‡½æ•°ä¸­å¤„ç†æ‰€æœ‰å‚è€ƒçº¿æ˜¾ç¤º

            chart.update();
        }

        // è®¡ç®—ç°é‡‘æµæŒ‡æ ‡
        // åŠ¨æ€è®¡ç®—åŸºäºæŒ‡å®šæœˆä»½çš„ç°é‡‘æµæ•°æ®
        function calculateDynamicCashFlow(storeData, indicatorKey, balancePoint, targetIndex) {
            const result = {
                monthly: [],
                quarterly: [],
                semiAnnual: [],
                ninthMonths: [], // æ·»åŠ 9ä¸ªæœˆæ•°æ®æ•°ç»„
                annual: []
            };

            // è®¡ç®—æŒ‡å®šæœˆä»½çš„ç°é‡‘æµ
            result.monthly = storeData.map((item, index) => {
                if (index === targetIndex) {
                    const value = parseValue(item[indicatorKey]);
                    return value - balancePoint;
                }
                return null;
            });

            // è®¡ç®—åŸºäºæŒ‡å®šæœˆä»½çš„å‘¨æœŸç°é‡‘æµ
            function calculatePeriodCashFlowFromTarget(periodMonths, targetIndex) {
                const periodResult = [];
                for (let i = 0; i < storeData.length; i++) {
                    if (i === targetIndex && targetIndex >= periodMonths - 1) {
                        // ä»ç›®æ ‡æœˆä»½å¾€å‰æ¨periodMonthsä¸ªæœˆ
                        let revenueSum = 0;
                        for (let j = targetIndex - periodMonths + 1; j <= targetIndex; j++) {
                            revenueSum += parseValue(storeData[j][indicatorKey]);
                        }
                        // è¿‘Nä¸ªæœˆç°é‡‘æµ = è¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—å¹³è¡¡çº¿
                        periodResult.push(revenueSum - (periodMonths * balancePoint));
                    } else {
                        periodResult.push(null);
                    }
                }
                return periodResult;
            }

            result.quarterly = calculatePeriodCashFlowFromTarget(3, targetIndex);
            result.semiAnnual = calculatePeriodCashFlowFromTarget(6, targetIndex);
            result.ninthMonths = calculatePeriodCashFlowFromTarget(9, targetIndex); // æ·»åŠ 9ä¸ªæœˆè®¡ç®—
            result.annual = calculatePeriodCashFlowFromTarget(12, targetIndex);

            return result;
        }

        // åŠ¨æ€æ›´æ–°ç°é‡‘æµè¡¨æ ¼
        function updateCashFlowTable(storeData, indicator, targetIndex) {
            const storeName = storeData.length > 0 ? storeData[0]['é—¨åº—'] : currentStore;
            // ä½¿ç”¨å‚è€ƒçº¿ç®¡ç†ç³»ç»Ÿè·å–å¹³è¡¡ç‚¹
            const balancePoint = referenceLineManager.getBalancePoint(indicator.key, storeName);

            // è®¡ç®—åŸºäºç›®æ ‡æœˆä»½çš„ç°é‡‘æµ
            const cashFlow = calculateDynamicCashFlow(storeData, indicator.key, balancePoint, targetIndex);

            // æ›´æ–°è¡¨æ ¼
            const tbody = document.getElementById(`cashflow-tbody-${indicator.key}`);
            if (!tbody) return;

            // æ¸…ç©ºç°æœ‰å†…å®¹
            tbody.innerHTML = '';

            // è·å–ç›®æ ‡æœˆä»½ä¿¡æ¯
            const targetMonth = storeData[targetIndex];
            const monthLabel = `${targetMonth['å¹´ä»½']}-${targetMonth['æœˆä»½'].padStart(2, '0')}`;

            const periods = [
                { name: monthLabel, data: cashFlow.monthly, index: targetIndex },
                { name: `è¿‘3ä¸ªæœˆ(${monthLabel})`, data: cashFlow.quarterly, index: targetIndex },
                { name: `è¿‘6ä¸ªæœˆ(${monthLabel})`, data: cashFlow.semiAnnual, index: targetIndex },
                { name: `è¿‘9ä¸ªæœˆ(${monthLabel})`, data: cashFlow.ninthMonths, index: targetIndex }, // ä¿®å¤9ä¸ªæœˆæ•°æ®å¼•ç”¨
                { name: `è¿‘12ä¸ªæœˆ(${monthLabel})`, data: cashFlow.annual, index: targetIndex }
            ];

            periods.forEach(period => {
                if (period.data[period.index] !== null) {
                    const value = period.data[period.index];
                    const isPositive = value > 0;
                    const status = isPositive ? 'ç›ˆä½™' : 'äºæŸ';
                    // åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ˆè­¦ç¤ºï¼‰ï¼ŒäºæŸç”¨ç»¿è‰²
                    const statusColor = isPositive ? '#e74c3c' : '#27ae60';
                    const sign = isPositive ? '+' : '';

                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #e9ecef';
                    row.innerHTML = `
                        <td style="padding: 12px; font-weight: 500;">${period.name}</td>
                        <td style="padding: 12px; text-align: right; font-weight: 600; color: ${statusColor};">
                            ${sign}${formatValue(value / 10000, 1)}ä¸‡
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <span style="display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; background: ${statusColor}20; color: ${statusColor}; border: 1px solid ${statusColor}40;">
                                ${status}
                            </span>
                        </td>
                    `;
                    tbody.appendChild(row);
                }
            });

            // æ›´æ–°è¡¨æ ¼æ ‡é¢˜ï¼Œæ·»åŠ å½“å‰æ‚¬æµ®æœˆä»½æç¤º
            const tableTitle = document.querySelector(`#cashflow-table-${indicator.key} .chart-title`);
            if (tableTitle) {
                const originalTitle = indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµçŠ¶æ€è¡¨' : 'ç›ˆäºçŠ¶æ€è¡¨';
                tableTitle.innerHTML = `${originalTitle} <span style="color: #666; font-size: 12px; font-weight: normal;">(å½“å‰: ${monthLabel})</span>`;
            }
        }

      // æ˜¾ç¤ºæ‚¬æµ®ä¿¡æ¯æ¡†
        function showHoverInfo(event, storeData, dataIndex, indicator) {
            // ç§»é™¤å·²å­˜åœ¨çš„ä¿¡æ¯æ¡†
            hideHoverInfo();

            const hoverInfo = document.createElement('div');
            hoverInfo.className = 'hover-info';
            hoverInfo.id = 'hoverInfo';

            const monthData = storeData[dataIndex];
            const monthLabel = `${monthData['å¹´ä»½']}-${monthData['æœˆä»½'].padStart(2, '0')}`;

            // è®¡ç®—ç°é‡‘æµæ•°æ®
            const storeName = monthData['é—¨åº—'];

            if (indicator) {
                // ä½¿ç”¨å‚è€ƒçº¿ç®¡ç†ç³»ç»Ÿè·å–å¹³è¡¡ç‚¹
                const balancePoint = referenceLineManager.getBalancePoint(indicator.key, storeName);

                // è®¡ç®—åŸºäºç›®æ ‡æœˆä»½çš„ç°é‡‘æµæ•°æ®
                const cashFlow = calculateDynamicCashFlow(storeData, indicator.key, balancePoint, dataIndex);

                let content = `
                    <div class="month">ğŸ“… ${monthLabel}</div>
                `;

                // æ·»åŠ è¯¥æœˆçš„åŸºç¡€æ•°æ®
                const value = parseValue(monthData[indicator.key]);
                const formattedValue = formatValue(value / indicator.scale, 1);

                // è·å–å½“å‰é€‰ä¸­çš„å‚è€ƒçº¿ä¿¡æ¯
                const selectedLine = referenceLineManager.getSelectedLine(indicator.key, storeName);
                const distanceFromLine = selectedLine ? value - selectedLine.value : 0;
                const distanceText = selectedLine ?
                    (distanceFromLine > 0 ? `é«˜äº${selectedLine.name} ${formatValue(Math.abs(distanceFromLine) / 10000, 1)}ä¸‡` :
                     distanceFromLine < 0 ? `ä½äº${selectedLine.name} ${formatValue(Math.abs(distanceFromLine) / 10000, 1)}ä¸‡` :
                     `ä¸${selectedLine.name}æŒå¹³`) : '';

                content += `
                    <div class="data">
                        <span class="label">${indicator.label}:</span>
                        <span class="value">${formattedValue}${indicator.unit}</span>
                    </div>
                `;

                // æ·»åŠ å‚è€ƒçº¿è·ç¦»ä¿¡æ¯
                if (distanceText) {
                    content += `
                        <div class="data" style="font-size: 11px; margin: 2px 0;">
                            <span class="label" style="font-size: 10px;">è·ç¦»å‚è€ƒçº¿:</span>
                            <span class="value" style="color: ${distanceFromLine >= 0 ? '#27ae60' : '#e74c3c'}; font-size: 10px;">${distanceText}</span>
                        </div>
                    `;
                }

                // æ·»åŠ åˆ†å‰²çº¿
                content += `
                    <div style="margin: 4px 0; padding-top: 4px; border-top: 1px solid rgba(255,255,255,0.3);"></div>
                `;

                // æ˜¾ç¤ºå„ä¸ªå‘¨æœŸçš„ç°é‡‘æµæ•°æ®
                const periods = [
                    { name: 'å½“æœˆ', data: cashFlow.monthly, index: dataIndex },
                    { name: 'è¿‘3ä¸ªæœˆ', data: cashFlow.quarterly, index: dataIndex },
                    { name: 'è¿‘6ä¸ªæœˆ', data: cashFlow.semiAnnual, index: dataIndex },
                    { name: 'è¿‘9ä¸ªæœˆ', data: cashFlow.ninthMonths, index: dataIndex },
                    { name: 'è¿‘12ä¸ªæœˆ', data: cashFlow.annual, index: dataIndex }
                ];

                // æ³¨ï¼šç§»é™¤äº†è®¡ç®—åŸºå‡†ä¿¡æ¯æ˜¾ç¤ºï¼ŒæŒ‰ç”¨æˆ·è¦æ±‚ç®€åŒ–æ‚¬æµ®æç¤º

                periods.forEach(period => {
                    if (period.data[period.index] !== null) {
                        const periodValue = period.data[period.index];
                        const isPositive = periodValue > 0;
                        const status = isPositive ? 'ç›ˆä½™' : (periodValue < 0 ? 'äºæŸ' : 'æŒå¹³');
                        const statusColor = isPositive ? '#e74c3c' : (periodValue < 0 ? '#27ae60' : '#f39c12'); // çº¢è‰²ç›ˆä½™ï¼Œç»¿è‰²äºæŸï¼Œé»„è‰²æŒå¹³
                        const sign = isPositive ? '+' : (periodValue < 0 ? '' : '');

                        content += `
                            <div class="data" style="font-size: 11px; margin: 2px 0;">
                                <span class="label" style="font-size: 10px;">${period.name}:</span>
                                <span class="value" style="color: ${statusColor}; font-size: 10px; font-weight: bold;">${sign}${formatValue(Math.abs(periodValue) / 10000, 1)}ä¸‡ (${status})</span>
                            </div>
                        `;
                    }
                });

                hoverInfo.innerHTML = content;
            } else {
                hoverInfo.innerHTML = `<div class="month">ğŸ“… ${monthLabel}</div>`;
            }

            // å®šä½ä¿¡æ¯æ¡†
            document.body.appendChild(hoverInfo);

            // è®¾ç½®ä½ç½®ï¼ˆè·Ÿéšé¼ æ ‡ï¼Œä½†æœ‰åç§»é¿å…é®æŒ¡ï¼‰
            const mouseX = event.clientX;
            const mouseY = event.clientY;
            const infoBox = hoverInfo.getBoundingClientRect();

            let left = mouseX + 15;
            let top = mouseY - infoBox.height / 2;

            // ç¡®ä¿ä¿¡æ¯æ¡†ä¸ä¼šè¶…å‡ºå±å¹•è¾¹ç•Œ
            if (left + infoBox.width > window.innerWidth) {
                left = mouseX - infoBox.width - 15;
            }
            if (top < 10) {
                top = 10;
            }
            if (top + infoBox.height > window.innerHeight) {
                top = window.innerHeight - infoBox.height - 10;
            }

            hoverInfo.style.left = left + 'px';
            hoverInfo.style.top = top + 'px';
        }

        // éšè—æ‚¬æµ®ä¿¡æ¯æ¡†
        function hideHoverInfo() {
            const hoverInfo = document.getElementById('hoverInfo');
            if (hoverInfo) {
                hoverInfo.remove();
            }
        }

        function calculateCashFlow(storeData, indicatorKey, balancePoint) {
            const result = {
                monthly: [],
                quarterly: [],
                semiAnnual: [],
                ninthMonths: [], // æ·»åŠ 9ä¸ªæœˆæ•°æ®æ•°ç»„
                annual: []
            };

            // æœˆåº¦ç°é‡‘æµï¼ˆè¥æ”¶ - æ”¶æ”¯å¹³è¡¡çº¿ï¼‰
            result.monthly = storeData.map((item, index) => {
                const value = parseValue(item[indicatorKey]);
                return value - balancePoint;
            });

            // è®¡ç®—ç´¯è®¡ç°é‡‘æµï¼ˆ3ä¸ªæœˆã€6ä¸ªæœˆã€12ä¸ªæœˆï¼‰
            function calculatePeriodCashFlow(periodMonths) {
                const periodResult = [];
                for (let i = 0; i < storeData.length; i++) {
                    if (i < periodMonths - 1) {
                        periodResult.push(null); // æ•°æ®ä¸è¶³
                    } else {
                        // è®¡ç®—è¿‘Nä¸ªæœˆçš„æ€»è¥æ”¶
                        let revenueSum = 0;
                        for (let j = i - periodMonths + 1; j <= i; j++) {
                            revenueSum += parseValue(storeData[j][indicatorKey]);
                        }
                        // è¿‘Nä¸ªæœˆç°é‡‘æµ = è¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—å¹³è¡¡çº¿
                        periodResult.push(revenueSum - (periodMonths * balancePoint));
                    }
                }
                return periodResult;
            }

            result.quarterly = calculatePeriodCashFlow(3);
            result.semiAnnual = calculatePeriodCashFlow(6);
            result.ninthMonths = calculatePeriodCashFlow(9); // æ·»åŠ 9ä¸ªæœˆè®¡ç®—
            result.annual = calculatePeriodCashFlow(12);

            return result;
        }

        // åˆ›å»ºç°é‡‘æµè¡¨æ ¼
        function createCashFlowTable(container, storeData, indicator, balancePoint) {
            const cashFlow = calculateCashFlow(storeData, indicator.key, balancePoint);
            const latestIndex = storeData.length - 1;
            // ä»storeDataè·å–é—¨åº—åç§°
            const storeName = storeData.length > 0 ? storeData[0]['é—¨åº—'] : currentStore;

            // åˆ›å»ºæ•´åˆçš„ç°é‡‘æµå¡ç‰‡ï¼ˆåŒ…å«è¡¨æ ¼å’Œå›¾è¡¨ï¼‰
            const combinedContainer = document.createElement('div');
            combinedContainer.className = 'chart-container special-chart';
            combinedContainer.style.marginTop = '20px';

            // è·å–å½“å‰é€‰ä¸­çš„å‚è€ƒçº¿ä¿¡æ¯
            const selectedLine = referenceLineManager.getSelectedLine(indicator.key, storeName);
            const selectedLineName = selectedLine ? selectedLine.name : (indicator.key === 'æ€»è¥æ”¶' ? 'æ”¶æ”¯å¹³è¡¡çº¿' : 'ç›ˆäºå¹³è¡¡çº¿');
            const selectedLineValue = selectedLine ? formatValue(selectedLine.value / 10000, 1) + 'ä¸‡' : '';

            const tableTitle = indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµè¡¨' : 'ç›ˆäºçŠ¶æ€è¡¨';
            const chartTitle = indicator.key === 'æ€»è¥æ”¶' ? 'æœˆåº¦ç°é‡‘æµç›ˆäºå›¾' : 'æœˆåº¦ç›ˆäºèµ°åŠ¿å›¾';

            // æ›´æ–°å‰¯æ ‡é¢˜ï¼Œè¯´æ˜æ­£ç¡®çš„ç®—æ³•
            const algorithmText = indicator.key === 'æ€»è¥æ”¶'
                ? `ç®—æ³•ï¼šè¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—${selectedLineName}(${selectedLineValue})`
                : `ç®—æ³•ï¼šè¿‘Nä¸ªæœˆç¡®è®¤æ”¶å…¥ - NÃ—${selectedLineName}(${selectedLineValue})`;

            combinedContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${tableTitle} & ${chartTitle}</div>
                        <div class="chart-subtitle">${algorithmText}</div>
                    </div>
                </div>

                <!-- è¡¨æ ¼éƒ¨åˆ† -->
                <div style="padding: 20px; padding-bottom: 10px;">
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <thead style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <tr>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">æ—¶é—´æ®µ</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">${indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµé‡‘é¢' : 'ç›ˆäºé‡‘é¢'}</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">çŠ¶æ€</th>
                            </tr>
                        </thead>
                        <tbody id="cashflow-tbody-${indicator.key}">
                        </tbody>
                    </table>
                </div>

                <!-- å›¾è¡¨éƒ¨åˆ† -->
                <div style="padding: 0 20px 20px 20px;">
                    <div class="chart-wrapper" style="height: 300px;">
                        <canvas id="monthly-cashflow-chart-${indicator.key}"></canvas>
                    </div>
                </div>
            `;

            container.appendChild(combinedContainer);

            // å¡«å……è¡¨æ ¼æ•°æ®
            const tbody = document.getElementById(`cashflow-tbody-${indicator.key}`);

                const periods = [
                { name: 'å½“æœˆ', data: cashFlow.monthly, index: latestIndex },
                { name: 'è¿‘3ä¸ªæœˆ', data: cashFlow.quarterly, index: latestIndex },
                { name: 'è¿‘6ä¸ªæœˆ', data: cashFlow.semiAnnual, index: latestIndex },
                { name: 'è¿‘9ä¸ªæœˆ', data: cashFlow.ninthMonths, index: latestIndex }, // æ·»åŠ 9ä¸ªæœˆæ•°æ®
                { name: 'è¿‘12ä¸ªæœˆ', data: cashFlow.annual, index: latestIndex }
            ];

            periods.forEach(period => {
                if (period.data[period.index] !== null) {
                    const value = period.data[period.index];
                    const isPositive = value > 0;
                    const status = isPositive ? 'ç›ˆä½™' : 'äºæŸ';
                    // åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ˆè­¦ç¤ºï¼‰ï¼ŒäºæŸç”¨ç»¿è‰²
                    const statusColor = isPositive ? '#e74c3c' : '#27ae60';
                    const sign = isPositive ? '+' : '';

                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #e9ecef';
                    row.innerHTML = `
                        <td style="padding: 12px; font-weight: 500;">${period.name}</td>
                        <td style="padding: 12px; text-align: right; font-weight: 600; color: ${statusColor};">
                            ${sign}${formatValue(value / 10000, 1)}ä¸‡
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <span style="display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; background: ${statusColor}20; color: ${statusColor}; border: 1px solid ${statusColor}40;">
                                ${status}
                            </span>
                        </td>
                    `;
                    tbody.appendChild(row);
                }
            });

            // åœ¨åŒä¸€ä¸ªå¡ç‰‡ä¸­åˆ›å»ºæœˆåº¦ç›ˆäºå›¾è¡¨
            createMonthlyCashFlowChartInCard(combinedContainer, storeData, indicator, balancePoint);
        }

        // åœ¨æ•´åˆå¡ç‰‡ä¸­åˆ›å»ºæœˆåº¦ç›ˆäºå›¾è¡¨
        function createMonthlyCashFlowChartInCard(combinedContainer, storeData, indicator, balancePoint) {
            // è·å–æ‰€æœ‰æœˆä»½çš„æ•°æ®
            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);
            const monthlyCashFlow = storeData.map((item, index) => {
                const value = parseValue(item[indicator.key]);
                return value - balancePoint;
            });

            // å‡†å¤‡é¢œè‰²æ•°ç»„ - ç›ˆä½™ç”¨çº¢è‰²ï¼ŒäºæŸç”¨ç»¿è‰²
            const colors = monthlyCashFlow.map(value => value > 0 ? '#e74c3c' : '#27ae60');

            // è·å–canvaså…ƒç´ 
            const canvas = document.getElementById(`monthly-cashflow-chart-${indicator.key}`);
            const ctx = canvas.getContext('2d');

            // åˆ›å»ºå›¾è¡¨
            charts[`monthly-cashflow-chart-${indicator.key}`] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµ' : 'ç›ˆäº',
                        data: monthlyCashFlow,
                        backgroundColor: colors.map(color => color + '80'), // æ·»åŠ é€æ˜åº¦
                        borderColor: colors,
                        borderWidth: 2,
                        borderRadius: 5,
                        borderSkipped: false,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false // å®Œå…¨ç¦ç”¨å›¾ä¾‹
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const status = value > 0 ? 'ç›ˆä½™' : 'äºæŸ';
                                    return `${status}: Â¥${Math.abs(value / 10000).toFixed(1)}ä¸‡`;
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: function(value) {
                                return `${(value / 10000).toFixed(1)}ä¸‡`;
                            },
                            anchor: 'end',
                            align: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ç°é‡‘æµ (ä¸‡å…ƒ)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return (value / 10000).toFixed(1) + 'ä¸‡';
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            // æš‚æ—¶ç§»é™¤ç›ˆäºå¹³è¡¡çº¿ï¼Œä»¥è§£å†³å›¾ä¾‹é—®é¢˜
            // charts[`monthly-cashflow-chart-${indicator.key}`].data.datasets.push({
            //     label: 'ç›ˆäºå¹³è¡¡çº¿', // è®¾ç½®æ ‡ç­¾ï¼Œä½†ä¼šé€šè¿‡å¤šç§æ–¹å¼éšè—
            //     type: 'line', // æ˜ç¡®æŒ‡å®šä¸ºçº¿å‹
            //     data: new Array(monthlyCashFlow.length).fill(0),
            //     borderColor: '#f39c12',
            //     borderWidth: 2,
            //     borderDash: [8, 4],
            //     pointRadius: 0,
            //     fill: false,
            //     tension: 0,
            //     hidden: true, // å®Œå…¨éšè—æ•°æ®é›†
            //     hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
            //     order: 1, // ç¡®ä¿çº¿åœ¨æŸ±å­åé¢æ¸²æŸ“
            //     skipNull: true, // è·³è¿‡ç©ºå€¼
            //     yAxisID: 'y', // ç¡®ä¿ä½¿ç”¨Yè½´
            //     borderWidth: 2,
            //     borderDash: [8, 4]
            // });

            // æ›´æ–°å›¾è¡¨
            charts[`monthly-cashflow-chart-${indicator.key}`].update();
        }

        // åˆ›å»ºæœˆåº¦ç›ˆäºå›¾è¡¨ï¼ˆæ˜¾ç¤ºåœ¨ç°é‡‘æµè¡¨æ ¼ä¸‹æ–¹ï¼‰
        function createMonthlyCashFlowChart(container, storeData, indicator, balancePoint) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.style.marginTop = '10px';
            chartContainer.style.background = '#f8f9fa';

            const chartTitle = indicator.key === 'æ€»è¥æ”¶' ? 'æœˆåº¦ç°é‡‘æµç›ˆäºå›¾' : 'æœˆåº¦ç°é‡‘æ”¶æ”¯ç›ˆäºå›¾';
            const algorithmText = 'æ˜¾ç¤ºæ¯ä¸ªæœˆç›¸å¯¹äºå¹³è¡¡çº¿çš„ç›ˆäºçŠ¶å†µ';

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${chartTitle}</div>
                        <div class="chart-subtitle">${algorithmText}</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="monthly-cashflow-chart-${indicator.key}"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            // è·å–æ‰€æœ‰æœˆä»½çš„æ•°æ®
            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);
            const monthlyCashFlow = storeData.map((item, index) => {
                const value = parseValue(item[indicator.key]);
                return value - balancePoint;
            });

            // å‡†å¤‡é¢œè‰²æ•°ç»„ - åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ŒäºæŸç”¨ç»¿è‰²
            const colors = monthlyCashFlow.map(value => value > 0 ? '#e74c3c' : '#27ae60');

            const ctx = document.getElementById(`monthly-cashflow-chart-${indicator.key}`).getContext('2d');

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: indicator.key === 'æ€»è¥æ”¶' ? 'æœˆåº¦ç°é‡‘æµ' : 'æœˆåº¦ç°é‡‘æ”¶æ”¯',
                        data: monthlyCashFlow,
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 2,
                            padding: 1,
                            formatter: function(value) {
                                const sign = value > 0 ? '+' : '';
                                return `${sign}${formatValue(value / 10000, 1)}`;
                            },
                            anchor: 'end',
                            align: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ç›ˆäºé‡‘é¢ï¼ˆä¸‡å…ƒï¼‰',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatValue(value / 10000, 1) + 'ä¸‡';
                                },
                                font: {
                                    size: 9
                                }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            });
        }

        // åˆ›å»ºç°é‡‘æµå›¾è¡¨ï¼ˆæ›¿ä»£è¡¨æ ¼ï¼‰
        function createCashFlowChart(container, storeData, indicator, balancePoint) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.style.marginTop = '20px';
            chartContainer.style.background = '#f8f9fa';

            // è·å–å½“å‰é€‰ä¸­çš„å‚è€ƒçº¿ä¿¡æ¯
            const selectedLine = referenceLineManager.getSelectedLine(indicator.key, storeName);
            const selectedLineName = selectedLine ? selectedLine.name : (indicator.key === 'æ€»è¥æ”¶' ? 'æ”¶æ”¯å¹³è¡¡çº¿' : 'ç›ˆäºå¹³è¡¡çº¿');
            const selectedLineValue = selectedLine ? formatValue(selectedLine.value / 10000, 1) + 'ä¸‡' : '';

            const tableTitle = indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµç›ˆäºçŠ¶æ€å›¾' : 'ç°é‡‘æ”¶æ”¯ç›ˆäºçŠ¶æ€å›¾';
            const algorithmText = indicator.key === 'æ€»è¥æ”¶'
                ? `ç®—æ³•ï¼šè¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—${selectedLineName}(${selectedLineValue})`
                : `ç®—æ³•ï¼šè¿‘Nä¸ªæœˆç¡®è®¤æ”¶å…¥ - NÃ—${selectedLineName}(${selectedLineValue})`;

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${tableTitle}</div>
                        <div class="chart-subtitle">${algorithmText}</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="cashflow-chart-${indicator.key}"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            const labels = ['å½“æœˆ', 'è¿‘3ä¸ªæœˆ', 'è¿‘6ä¸ªæœˆ', 'è¿‘9ä¸ªæœˆ', 'è¿‘12ä¸ªæœˆ'];
            const cashFlow = calculateCashFlow(storeData, indicator.key, balancePoint);
            const latestIndex = storeData.length - 1;

            // å‡†å¤‡æ•°æ®
            const chartData = [
                cashFlow.monthly[latestIndex],
                cashFlow.quarterly[latestIndex],
                cashFlow.semiAnnual[latestIndex],
                cashFlow.ninthMonths[latestIndex], // æ·»åŠ 9ä¸ªæœˆæ•°æ®
                cashFlow.annual[latestIndex]
            ].filter(value => value !== null);

            // å‡†å¤‡å¯¹åº”æ ‡ç­¾
            const validLabels = [];
            const validData = [];
            const colors = []; // æ ¹æ®ç›ˆäºçŠ¶æ€è®¾ç½®é¢œè‰²

            for (let i = 0; i < chartData.length; i++) {
                if (chartData[i] !== null) {
                    validLabels.push(labels[i]);
                    validData.push(chartData[i]);
                    // åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ŒäºæŸç”¨ç»¿è‰²
                    colors.push(chartData[i] > 0 ? '#e74c3c' : '#27ae60');
                }
            }

            const ctx = document.getElementById(`cashflow-chart-${indicator.key}`).getContext('2d');

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: validLabels,
                    datasets: [{
                        label: indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµ' : 'ç°é‡‘æ”¶æ”¯',
                        data: validData,
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 11,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                const sign = value > 0 ? '+' : '';
                                return `${sign}${formatValue(value / 10000, 1)}ä¸‡`;
                            },
                            anchor: 'end',
                            align: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'é‡‘é¢ï¼ˆä¸‡å…ƒï¼‰',
                                font: {
                                    size: 12
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatValue(value / 10000, 1) + 'ä¸‡';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // åˆ›å»ºæ–°å®¢åˆ†æå›¾è¡¨
        function createAClassCombinedChart(container, storeData) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container special-chart';

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">æ–°å®¢åˆ†æ</div>
                        <div class="chart-subtitle">ç¾å›¢ç‚¹è¯„ã€è·¯è¿‡ã€è€å¸¦æ–°ã€å…¶ä»–æ¸ é“å¯¹æ¯”</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="aClassCombinedChart"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);

            // å‚è€ƒåŸºç¡€æŒ‡æ ‡çš„å¤„ç†æ–¹å¼ï¼Œæ¯ä¸ªæ•°æ®é›†ç‹¬ç«‹å¤„ç†
            const datasets = [];

            aClassIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                const borderColor = indicator.color;
                const backgroundColor = indicator.color + '20';

                datasets.push({
                    label: indicator.label,
                    data: values,
                    borderColor: borderColor,
                    backgroundColor: backgroundColor,
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: borderColor,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    tension: 0.2,
                    fill: false
                });
            });

            const ctx = document.getElementById('aClassCombinedChart').getContext('2d');

            charts.aClassCombinedChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true, // å¯ç”¨å›¾ä¾‹ï¼Œè®©ç”¨æˆ·å¯ä»¥æ§åˆ¶æ˜¾ç¤º/éšè—
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                },
                                boxWidth: 12,
                                padding: 15,
                                // è‡ªå®šä¹‰å›¾ä¾‹ç”Ÿæˆï¼Œåªæ˜¾ç¤ºä¸»è¦æ•°æ®é›†
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        // åªè¿”å›å‰aClassIndicators.lengthä¸ªæ•°æ®é›†ï¼ˆä¸»è¦æ•°æ®é›†ï¼‰
                                        return data.datasets.slice(0, aClassIndicators.length).map((dataset, i) => ({
                                            text: dataset.label,
                                            fillStyle: dataset.borderColor,
                                            strokeStyle: dataset.borderColor,
                                            lineWidth: dataset.borderWidth,
                                            pointStyle: 'rectRounded',
                                            hidden: !chart.isDatasetVisible(i),
                                            datasetIndex: i
                                        }));
                                    }
                                    return [];
                                }
                            },
                            // è‡ªå®šä¹‰ç‚¹å‡»å¤„ç†
                            onClick: function(e, legendItem, legend) {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);

                                // åˆ‡æ¢ä¸»æ•°æ®é›†çš„æ˜¾ç¤ºçŠ¶æ€
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;

                                // åŒæ—¶åˆ‡æ¢ç›¸å…³çš„å‚è€ƒçº¿æ•°æ®é›†
                                for (let i = aClassIndicators.length; i < chart.data.datasets.length; i++) {
                                    const refMeta = chart.getDatasetMeta(i);
                                    const refDataset = chart.data.datasets[i];
                                    // å‚è€ƒçº¿è·Ÿéšå¯¹åº”çš„ä¸»æ•°æ®é›†çš„çŠ¶æ€
                                    if (refDataset.datasetIndexKey === 'reference' && refDataset.mainDatasetIndex === index) {
                                        refMeta.hidden = meta.hidden;
                                    }
                                }

                                chart.update();
                            }
                        },
                        tooltip: {
                            filter: function(tooltipItem) {
                                // åªæ˜¾ç¤ºä¸»è¦çš„æ•°æ®é›†ï¼Œéšè—æ‰€æœ‰å‚è€ƒçº¿
                                return tooltipItem.datasetIndex < aClassIndicators.length;
                            },
                            callbacks: {
                                label: function(context) {
                                    const datasetLabel = context.dataset.label || '';
                                    if (datasetLabel === 'æ–°å®¢æ€»è®¡') {
                                        const total = aClassIndicators.reduce((sum, indicator) => {
                                            return sum + parseValue(storeData[context.dataIndex][indicator.key]);
                                        }, 0);
                                        return `æ–°å®¢æ€»è®¡: ${formatValue(total, 1)}äºº`;
                                    } else {
                                        return `${datasetLabel}: ${formatValue(context.parsed.y, 1)}äºº`;
                                    }
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // åªæ˜¾ç¤ºä¸»è¦æ•°æ®é›†çš„æ ‡ç­¾ï¼Œéšè—æ‰€æœ‰å‚è€ƒçº¿æ ‡ç­¾
                                return context.datasetIndex < aClassIndicators.length;
                            },
                            color: function(context) {
                                return context.dataset.borderColor;
                            },
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: function(context) {
                                return context.dataset.borderColor;
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                return formatValue(value, 1) + 'äºº';
                            },
                            align: function(context) {
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                const y = dataset.data[dataIndex];
                                const scaledY = chart.scales.y.getPixelForValue(y);

                                // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸ŠåŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                                if (scaledY < chartArea.top + 50) {
                                    return 'bottom';
                                }

                                // æ£€æŸ¥ç›¸é‚»æ•°æ®ç‚¹çš„å€¼ï¼Œé¿å…é‡å 
                                const prevY = dataIndex > 0 ? dataset.data[dataIndex - 1] : null;
                                const nextY = dataIndex < dataset.data.length - 1 ? dataset.data[dataIndex + 1] : null;

                                // å¦‚æœä¸ç›¸é‚»ç‚¹å€¼æ¥è¿‘ï¼Œäº¤æ›¿æ˜¾ç¤ºä½ç½®
                                if (prevY && Math.abs(y - prevY) < (chart.scales.y.max - chart.scales.y.min) * 0.08) {
                                    return dataIndex % 2 === 0 ? 'top' : 'bottom';
                                }

                                return 'top';
                            },
                            offset: 8
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'äººæ•°',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + 'äºº';
                                },
                                font: {
                                    size: 11
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'å˜åŒ–é€Ÿåº¦ (%)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è®¾ç½®åˆç†çš„èŒƒå›´
                            min: -100,
                            max: 100
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });

            // ä¸ºæ¯ä¸ªæ•°æ®é›†æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡
            aClassIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                setTimeout(() => {
                    addAnalysisIndicators(charts.aClassCombinedChart, values, 1, 'äºº', storeData[0]['é—¨åº—'], index);
                }, 100);
            });
        }


        
      // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            init();

            // è®¾ç½®å¯¼èˆªäº¤äº’äº‹ä»¶
            setupNavigationInteraction();
        });

        // è®¾ç½®å¯¼èˆªäº¤äº’åŠŸèƒ½
        function setupNavigationInteraction() {
            const trigger = document.getElementById('chartNavigationTrigger');
            const navigation = document.getElementById('chartNavigation');
            let isNavVisible = false;
            let hideTimeout;

            // é¼ æ ‡è¿›å…¥è§¦å‘æŒ‰é’®æ—¶æ˜¾ç¤ºå¯¼èˆª
            trigger.addEventListener('mouseenter', function() {
                clearTimeout(hideTimeout);
                showNavigation();
            });

            // é¼ æ ‡è¿›å…¥å¯¼èˆªé¢æ¿æ—¶ä¿æŒæ˜¾ç¤º
            navigation.addEventListener('mouseenter', function() {
                clearTimeout(hideTimeout);
            });

            // é¼ æ ‡ç¦»å¼€å¯¼èˆªé¢æ¿æ—¶å»¶è¿Ÿéšè—
            navigation.addEventListener('mouseleave', function() {
                hideTimeout = setTimeout(() => {
                    hideNavigation();
                }, 300);
            });

            // é¼ æ ‡ç¦»å¼€è§¦å‘æŒ‰é’®æ—¶å»¶è¿Ÿéšè—
            trigger.addEventListener('mouseleave', function() {
                hideTimeout = setTimeout(() => {
                    hideNavigation();
                }, 300);
            });

            // ç‚¹å‡»è§¦å‘æŒ‰é’®åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
            trigger.addEventListener('click', function() {
                if (isNavVisible) {
                    hideNavigation();
                } else {
                    showNavigation();
                }
            });

            // ç‚¹å‡»å¯¼èˆªé¢æ¿å¤–çš„åŒºåŸŸéšè—å¯¼èˆª
            document.addEventListener('click', function(e) {
                if (!trigger.contains(e.target) && !navigation.contains(e.target)) {
                    hideNavigation();
                }
            });

            // æ˜¾ç¤ºå¯¼èˆª
            function showNavigation() {
                navigation.classList.add('show');
                trigger.classList.add('active');
                isNavVisible = true;
            }

            // éšè—å¯¼èˆª
            function hideNavigation() {
                navigation.classList.remove('show');
                trigger.classList.remove('active');
                isNavVisible = false;
            }
        }
    </script>
</body>
</html>