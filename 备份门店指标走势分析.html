<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é—¨åº—ä¸šåŠ¡æŒ‡æ ‡èµ°åŠ¿åˆ†æç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0/dist/chartjs-plugin-datalabels.min.js"></script>
        <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .store-selector {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .store-tabs {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .store-tab {
            padding: 10px 25px;
            border: none;
            background: white;
            color: #495057;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .store-tab:hover {
            background: #e9ecef;
        }

        .store-tab.active {
            background: white;
            color: #667eea;
            border-color: #667eea;
            border-bottom-color: white;
            position: relative;
            top: 2px;
        }

        .content {
            padding: 30px;
            background: white;
        }

        .charts-grid {
            display: flex;
            flex-direction: column;
            gap: 35px;
        }

        .chart-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
            margin-bottom: 30px;
            position: relative;
        }

        .chart-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
            border-color: #dee2e6;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .chart-container:hover::before {
            opacity: 0.1;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .chart-subtitle {
            font-size: 12px;
            color: #6c757d;
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }


        .legend-custom {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        /* å›¾è¡¨å¯¼èˆªæ ·å¼ - æ‚¬æµ®è§¦å‘ */
        .chart-navigation-trigger {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1001;
            transition: all 0.3s ease;
            color: white;
            font-size: 18px;
        }

        .chart-navigation-trigger:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .chart-navigation-trigger.active {
            background: #e74c3c;
        }

        .chart-navigation {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
            z-index: 1000;
            max-height: 70vh;
            overflow-y: auto;
            min-width: 150px;
            opacity: 0;
            visibility: hidden;
            transform: translateX(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .chart-navigation.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
            pointer-events: all;
        }

        .chart-navigation:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        /* å¯¼èˆªæ ‡é¢˜ */
        .navigation-header {
            user-select: none;
            margin-bottom: 10px;
            position: relative;
        }

        /* å“åº”å¼æ—¶éšè—å¯¼èˆª */
        @media (max-width: 1200px) {
            .chart-navigation-trigger {
                top: auto;
                bottom: 20px;
            }

            .chart-navigation {
                top: auto;
                bottom: 70px;
                max-height: 200px;
                max-width: 200px;
            }
        }

        @media (max-width: 768px) {
            .chart-navigation-trigger,
            .chart-navigation {
                display: none;
            }
        }

        .chart-navigation h4 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #2c3e50;
            font-weight: 600;
        }

        .nav-item {
            display: block;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            text-decoration: none;
            color: #495057;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-item:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: translateX(-2px);
        }

        .nav-item.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .nav-group {
            margin-bottom: 15px;
        }

        .nav-group-title {
            font-size: 11px;
            font-weight: bold;
            color: #6c757d;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .charts-grid {
                flex-direction: column;
            }

            .store-tabs {
                flex-wrap: wrap;
            }

                }
    /* è½¬åŒ–åˆ†æå›¾è¡¨æ ·å¼ */
        .chart-subsection {
            margin-bottom: 30px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        .chart-subsection::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
        }

        .subsection-title {
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            border-left: 3px solid #667eea;
        }

        .chart-wrapper-small {
            height: 350px;
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 1px 6px rgba(0,0,0,0.05);
            border: 1px solid #f1f3f5;
        }

        /* è½¬åŒ–ç‡å›¾è¡¨ç‰¹æ®Šé«˜åº¦ */
        .chart-wrapper-small.rate-chart {
            height: 300px;
        }

        .special-chart {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            padding: 28px;
            border-radius: 18px;
            border: 2px solid #e9ecef;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            position: relative;
            margin-bottom: 35px;
        }

        .special-chart::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 18px 18px 0 0;
        }

        /* å›¾ä¾‹æ ·å¼ä¼˜åŒ– */
        .chart-container .chartjs-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
            margin: 0;
            background: rgba(248, 249, 250, 0.8);
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .chart-container .chartjs-legend li {
            display: inline-flex;
            align-items: center;
            margin: 4px 8px;
            padding: 4px 8px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            font-weight: 500;
        }

        .chart-container .chartjs-legend li:hover {
            background: #f8f9fa;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .chart-container .chartjs-legend li.hidden {
            opacity: 0.4;
            background: #f8f9fa;
        }

        .chart-container .chartjs-legend li span {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 6px;
            border: 2px solid transparent;
        }

        /* æ‚¬æµ®ä¿¡æ¯æ¡†æ ·å¼ */
        .hover-info {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            z-index: 10000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            max-width: 250px;
            line-height: 1.4;
        }

        .hover-info .month {
            color: #4fc3f7;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .hover-info .data {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .hover-info .label {
            color: #b0bec5;
        }

        .hover-info .value {
            color: #ffffff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>é—¨åº—ä¸šåŠ¡æŒ‡æ ‡èµ°åŠ¿åˆ†æç³»ç»Ÿ</h1>
            <p>2024å¹´6æœˆ - 2025å¹´10æœˆ æ•°æ®å¯è§†åŒ–åˆ†æ</p>
        </div>

        <div class="store-selector">
            <div class="store-tabs">
                <button class="store-tab" onclick="switchStore('å¹³å®‰', this)">å¹³å®‰åº—</button>
                <button class="store-tab active" onclick="switchStore('ä¾¨åŸ', this)">ä¾¨åŸåº—</button>
                <button class="store-tab" onclick="switchStore('åŒçº', this)">åŒçºåº—</button>
            </div>
        </div>

        <div class="content">
            <!-- å›¾è¡¨å¯¼èˆª -->
            <div class="chart-navigation-trigger" id="chartNavigationTrigger" title="å›¾è¡¨å¯¼èˆª">
                ğŸ“Š
            </div>

            <div class="chart-navigation" id="chartNavigation">
                <div class="navigation-header">
                    <h4>ğŸ“Š å›¾è¡¨å¯¼èˆª</h4>
                </div>
                <div id="navigationList">
                    <!-- åŠ¨æ€ç”Ÿæˆå¯¼èˆªé¡¹ -->
                </div>
            </div>


            <!-- å›¾è¡¨ç½‘æ ¼ -->
            <div class="charts-grid" id="chartsGrid">
                <!-- åŠ¨æ€ç”Ÿæˆå›¾è¡¨ -->
            </div>
        </div>
    </div>

    <script>
        // é—¨åº—åŸå§‹æ•°æ®
        const storeData = `é—¨åº—,å¹´ä»½,æœˆä»½,æ€»è¥æ”¶,ç¡®è®¤æ”¶å…¥,æ€»å®¢æµ,è€å®¢,Aç±»æ•°é‡,Aç±»è½¬åŒ–æ•°,Aç±»è½¬åŒ–åˆ†æ¯,Aç±»è½¬åŒ–ç‡,Aç±»ç¾å›¢ç‚¹è¯„,Aç±»è·¯è¿‡,Aç±»è€å¸¦æ–°,Aç±»å…¶ä»–,Bç±»æ•°é‡,Bç±»è½¬åŒ–æ•°,Bç±»è½¬åŒ–åˆ†æ¯,Bç±»è½¬åŒ–ç‡,Cç±»æ•°é‡,Cç±»è½¬åŒ–æ•°,Cç±»è½¬åŒ–åˆ†æ¯,Cç±»è½¬åŒ–ç‡,Dç±»æ•°é‡,Dç±»è½¬åŒ–æ•°,Dç±»è½¬åŒ–åˆ†æ¯,Dç±»è½¬åŒ–ç‡,æ€»æœ‰æ•ˆæœåŠ¡æ—¶é•¿,äººå‡æœåŠ¡æ—¶é•¿,æ‰“é±¼é‚€çº¦,ä¸»åŠ¨ä¸Šé—¨
å¹³å®‰,2024,6,180393,229957.52,287,182,105,7,93,7.53,47,46,12,0,24,5,24,20.83,47,12,42,28.57,111,2,102,1.96,398.92,1.39,0,182
å¹³å®‰,2024,7,188907,231999.16,270,180,90,6,77,7.79,44,32,13,1,27,7,27,25.93,40,9,37,24.32,113,1,108,0.93,389.01,1.44,5,175
å¹³å®‰,2024,8,314067,246841,269,197,72,8,54,14.81,28,22,18,4,20,8,21,38.1,48,21,46,45.65,129,5,122,4.1,418.75,1.56,61,136
å¹³å®‰,2024,9,254711.3,224437.85,241,159,82,6,66,9.09,28,38,16,0,15,4,16,25,38,16,38,42.11,106,8,101,7.92,367.08,1.52,60,99
å¹³å®‰,2024,10,199351,207426.5,228,156,72,9,56,16.07,35,21,16,0,12,4,12,33.33,36,14,36,38.89,108,0,99,0,341.5,1.5,56,100
å¹³å®‰,2024,11,353030,173567.8,199,152,47,4,33,12.12,11,18,14,4,10,4,11,36.36,31,12,37,32.43,111,32,112,28.57,282.75,1.42,39,113
å¹³å®‰,2024,12,195628,247758.73,252,183,69,5,49,10.2,22,25,21,1,7,4,8,50,25,12,22,54.55,151,7,133,5.26,376.5,1.49,73,110
å¹³å®‰,2025,1,249801,257916.6,249,172,77,5,64,7.81,38,26,13,0,9,6,10,60,35,8,30,26.67,128,3,119,2.52,363,1.46,60,112
å¹³å®‰,2025,2,145564,166363.35,197,145,52,1,41,2.44,13,27,11,0,6,2,7,28.57,36,13,36,36.11,103,4,94,4.26,281,1.43,45,100
å¹³å®‰,2025,3,163185.8,208588.8,259,192,67,2,50,4,15,33,18,1,22,7,23,30.43,28,7,28,25,142,3,132,2.27,354,1.37,87,105
å¹³å®‰,2025,4,110344,187065.5,225,165,60,1,45,2.22,27,17,16,0,11,1,11,9.09,33,5,32,15.62,121,2,107,1.87,317.08,1.41,87,78
å¹³å®‰,2025,5,224328.5,176459.86,218,137,81,7,66,10.61,29,37,15,0,11,5,12,41.67,29,15,31,48.39,97,10,90,11.11,304.5,1.4,51,86
å¹³å®‰,2025,6,171417,195897.71,248,150,98,7,92,7.61,33,57,7,1,10,7,10,70,28,5,23,21.74,112,3,103,2.91,328,1.32,46,104
å¹³å®‰,2025,7,160793,164630.62,207,143,64,14,58,24.14,24,30,6,4,4,2,4,50,27,9,25,36,112,5,104,4.81,299.5,1.45,48,95
å¹³å®‰,2025,8,232340,192993.76,258,181,77,8,64,12.5,23,36,13,5,17,7,18,38.89,26,15,26,57.69,138,6,118,5.08,345.42,1.34,58,123
å¹³å®‰,2025,9,180672,166100.92,211,151,60,8,45,17.78,23,21,16,0,12,2,12,16.67,24,6,21,28.57,115,7,111,6.31,285.25,1.35,64,87
å¹³å®‰,2025,10,159471,172176.06,209,161,48,2,43,4.65,20,18,7,2,20,4,20,20,27,14,26,53.85,114,2,103,1.94,289,1.38,66,95
ä¾¨åŸ,2024,6,169890.8,133466.3,159,119,40,7,29,24.14,19,8,12,1,9,3,9,33.33,25,13,25,52,85,1,73,1.37,235.34,1.48,0,119
ä¾¨åŸ,2024,7,102113,104448.75,122,95,27,2,20,10,13,3,7,4,8,5,9,55.56,13,5,12,41.67,74,0,70,0,181,1.48,0,95
ä¾¨åŸ,2024,8,145687.6,136204.11,160,133,27,3,20,15,19,1,7,0,9,2,9,22.22,29,8,24,33.33,95,6,82,7.32,235.33,1.47,51,82
ä¾¨åŸ,2024,9,158498,123386.41,131,102,29,4,15,26.67,11,2,14,2,9,4,9,44.44,18,11,14,78.57,75,2,67,2.99,198.92,1.52,30,72
ä¾¨åŸ,2024,10,89802.1,106259.87,109,89,20,4,17,23.53,14,2,4,0,5,2,5,40,16,5,15,33.33,68,3,65,4.62,179.77,1.65,44,45
ä¾¨åŸ,2024,11,222469,119253.9,136,109,27,3,21,14.29,17,2,7,1,5,1,6,16.67,22,14,23,60.87,82,9,80,11.25,198,1.46,25,84
ä¾¨åŸ,2024,12,124434,148569.99,150,119,31,2,18,11.11,11,6,14,0,8,2,8,25,6,3,6,50,105,6,95,6.32,225.33,1.5,41,78
ä¾¨åŸ,2025,1,186540,176896.82,131,113,18,0,11,0,10,1,7,0,6,1,6,16.67,4,3,4,75,103,6,93,6.45,209,1.6,55,58
ä¾¨åŸ,2025,2,101598,95208,121,91,30,2,23,8.7,16,7,7,0,2,1,2,50,12,3,11,27.27,77,4,67,5.97,165.25,1.37,54,37
ä¾¨åŸ,2025,3,96334.8,120439.74,141,102,39,2,29,6.9,22,5,11,1,1,0,1,0,18,9,18,50,83,2,75,2.67,195.58,1.39,56,46
ä¾¨åŸ,2025,4,104971,149778,178,148,30,2,19,10.53,14,2,12,2,5,2,5,40,22,7,19,36.84,121,1,102,0.98,257,1.44,74,74
ä¾¨åŸ,2025,5,184716,153015.97,183,145,38,9,24,37.5,19,4,15,0,3,1,3,33.33,17,7,17,41.18,125,9,112,8.04,285.83,1.56,78,67
ä¾¨åŸ,2025,6,182115,131117.05,160,128,32,1,17,5.88,8,9,15,0,8,6,9,66.67,18,8,17,47.06,102,6,92,6.52,234.25,1.46,66,62
ä¾¨åŸ,2025,7,156814,137025.66,159,124,35,6,25,24,18,6,10,1,2,0,2,0,18,7,15,46.67,104,6,92,6.52,242.5,1.53,60,64
ä¾¨åŸ,2025,8,155187.6,155128.33,181,144,37,2,23,8.7,11,11,14,1,4,2,4,50,21,12,21,57.14,119,4,108,3.7,269.5,1.49,67,77
ä¾¨åŸ,2025,9,158824.4,136634.14,173,146,27,5,23,21.74,13,9,5,0,6,3,6,50,15,5,13,38.46,125,9,115,7.83,246.83,1.43,62,84
ä¾¨åŸ,2025,10,141240.2,129073.71,166,135,31,1,21,4.76,10,7,10,4,8,4,8,50,18,9,17,52.94,109,5,102,4.9,244.24,1.47,36,99
åŒçº,2024,6,98969,127417.33,124,108,16,2,10,20,5,1,6,4,4,2,4,50,20,9,18,50,84,3,82,3.66,204.5,1.65,0,108
åŒçº,2024,7,119792.4,130163.6,121,104,17,1,9,11.11,9,0,8,0,6,1,6,16.67,24,11,23,47.83,74,3,68,4.41,198.01,1.64,0,104
åŒçº,2024,8,155487,140415.98,140,126,14,4,8,50,8,0,6,0,2,1,2,50,23,12,20,60,101,6,96,6.25,232.42,1.66,42,84
åŒçº,2024,9,189761,136369.99,136,113,23,3,15,20,9,4,9,1,4,2,4,50,23,14,22,63.64,86,8,82,9.76,222.92,1.64,40,73
åŒçº,2024,10,167997,138437.18,149,133,16,2,10,20,6,1,7,2,6,3,6,50,12,4,11,36.36,115,8,106,7.55,239.58,1.61,60,73
åŒçº,2024,11,227946.8,129672.85,142,131,11,2,6,33.33,2,2,5,2,2,1,2,50,18,8,17,47.06,111,14,103,13.59,208.75,1.47,58,73
åŒçº,2024,12,227661,188549.04,187,163,24,4,15,26.67,15,0,9,0,3,3,3,100,19,11,18,61.11,141,9,134,6.72,277.18,1.48,75,88
åŒçº,2025,1,169161.8,211218.82,163,142,21,2,8,25,4,3,14,0,2,1,2,50,14,7,13,53.85,126,4,110,3.64,265.75,1.63,94,48
åŒçº,2025,2,115015.8,142807.81,153,135,18,1,15,6.67,13,2,3,0,0,0,0,0,10,6,10,60,125,2,107,1.87,241,1.58,66,69
åŒçº,2025,3,110268,153596.99,153,133,20,6,13,46.15,12,1,7,0,8,1,8,12.5,17,11,17,64.71,108,1,103,0.97,252.75,1.65,68,65
åŒçº,2025,4,90469,148513.94,146,130,16,2,12,16.67,11,0,4,1,2,0,2,0,15,4,12,33.33,113,4,103,3.88,243.83,1.67,72,58
åŒçº,2025,5,172999,155684.7,162,140,22,7,13,53.85,9,4,9,0,3,3,4,75,20,5,15,33.33,117,7,103,6.8,257.25,1.59,80,60
åŒçº,2025,6,134828,126725.72,142,125,17,3,9,33.33,8,1,8,0,4,1,4,25,14,8,14,57.14,107,5,101,4.95,219,1.54,58,67
åŒçº,2025,7,162218,145744.34,162,131,31,6,23,26.09,21,2,8,0,3,1,3,33.33,12,6,10,60,116,4,106,3.77,258.75,1.6,56,75
åŒçº,2025,8,168787.8,166903.38,180,165,15,3,8,37.5,4,3,8,0,2,2,2,100,22,7,19,36.84,141,7,131,5.34,281.5,1.56,91,74
åŒçº,2025,9,112111,145032.65,163,146,17,3,7,42.86,5,1,10,1,5,4,5,80,16,11,16,68.75,125,2,115,1.74,257.25,1.58,83,63
åŒçº,2025,10,154352,158508.12,171,146,25,4,15,26.67,10,5,10,0,3,0,3,0,22,7,20,35,121,9,110,8.18,267.08,1.56,63,83`;

        let charts = {};
        let parsedData = [];
        let currentStore = 'ä¾¨åŸ';

        // å·¥å…·å‡½æ•° - ç§»åˆ°å‰é¢ä»¥é¿å…å‡½æ•°æœªå®šä¹‰é”™è¯¯
        function parseValue(value, isRate = false) {
            if (value === '' || value === null || value === undefined) return 0;
            const parsed = parseFloat(value);
            if (isNaN(parsed)) return 0;
            return parsed;
        }

        function formatValue(value, scale = 1) {
            if (scale === 10000) {
                return (value / scale).toFixed(1);
            }
            // å¯¹äºäººå‡æœåŠ¡æ—¶é•¿ç­‰å°æ•°å€¼ï¼Œä¿ç•™ä¸€ä½å°æ•°
            if (value < 10 && value % 1 !== 0) {
                return value.toFixed(1);
            }
            // å¯¹äºæ•´æ•°ï¼Œç¡®ä¿è¿”å›æ•´æ•°æ ¼å¼ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
            if (Number.isInteger(value) || (scale === 1 && Math.abs(value - Math.round(value)) < 0.000001)) {
                return Math.round(value);
            }
            // å…¶ä»–æƒ…å†µä¿ç•™åˆç†å°æ•°ä½
            if (scale === 1) {
                return value.toFixed(1);
            }
            return Math.round(value);
        }

        // æŒ‡æ ‡é…ç½® - æ’é™¤è½¬åŒ–ç±»ï¼Œå› ä¸ºè¦ç‰¹æ®Šå¤„ç†
        const indicators = [
            { key: 'æ€»è¥æ”¶', label: 'æ€»è¥æ”¶', unit: 'ä¸‡', scale: 10000 },
            { key: 'ç¡®è®¤æ”¶å…¥', label: 'ç¡®è®¤æ”¶å…¥', unit: 'ä¸‡', scale: 10000 },
            { key: 'æ€»å®¢æµ', label: 'æ€»å®¢æµ', unit: 'äºº', scale: 1 },
            { key: 'è€å®¢', label: 'è€å®¢æ•°é‡', unit: 'äºº', scale: 1 },
            { key: 'æ€»æœ‰æ•ˆæœåŠ¡æ—¶é•¿', label: 'æ€»æœ‰æ•ˆæœåŠ¡æ—¶é•¿', unit: 'å°æ—¶', scale: 1 },
            { key: 'äººå‡æœåŠ¡æ—¶é•¿', label: 'å®¢å‡æŠ¤ç†æ—¶é•¿', unit: 'å°æ—¶', scale: 1 },
            { key: 'æ‰“é±¼é‚€çº¦', label: 'æ‰“é±¼é‚€çº¦', unit: 'äºº', scale: 1 },
            { key: 'ä¸»åŠ¨ä¸Šé—¨', label: 'ä¸»åŠ¨ä¸Šé—¨', unit: 'äºº', scale: 1 }
        ];

    
        // è½¬åŒ–ç±»æŒ‡æ ‡é…ç½®
        const conversionIndicators = [
            { type: 'A', numKey: 'Aç±»è½¬åŒ–æ•°', denomKey: 'Aç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Aç±»è½¬åŒ–ç‡', color: '#FF6384' },
            { type: 'B', numKey: 'Bç±»è½¬åŒ–æ•°', denomKey: 'Bç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Bç±»è½¬åŒ–ç‡', color: '#36A2EB' },
            { type: 'C', numKey: 'Cç±»è½¬åŒ–æ•°', denomKey: 'Cç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Cç±»è½¬åŒ–ç‡', color: '#FFCE56' },
            { type: 'D', numKey: 'Dç±»è½¬åŒ–æ•°', denomKey: 'Dç±»è½¬åŒ–åˆ†æ¯', rateKey: 'Dç±»è½¬åŒ–ç‡', color: '#4BC0C0' }
        ];

        // è€å®¢åˆ†ææŒ‡æ ‡
        const customerTypeIndicators = [
            { key: 'è€å®¢', label: 'è€å®¢', color: '#FF6384' },
            { key: 'Bç±»æ•°é‡', label: 'Bç±»', color: '#36A2EB' },
            { key: 'Cç±»æ•°é‡', label: 'Cç±»', color: '#FFCE56' },
            { key: 'Dç±»æ•°é‡', label: 'Dç±»', color: '#4BC0C0' }
        ];

        // Aç±»å››åˆä¸€æŒ‡æ ‡
        const aClassIndicators = [
            { key: 'Aç±»æ•°é‡', label: 'æ–°å®¢æ€»æ•°', color: '#FF6384' },
            { key: 'Aç±»ç¾å›¢ç‚¹è¯„', label: 'ç¾å›¢ç‚¹è¯„', color: '#36A2EB' },
            { key: 'Aç±»è·¯è¿‡', label: 'è·¯è¿‡', color: '#FFCE56' },
            { key: 'Aç±»è€å¸¦æ–°', label: 'è€å¸¦æ–°', color: '#4BC0C0' },
            { key: 'Aç±»å…¶ä»–', label: 'å…¶ä»–', color: '#9966FF' }
        ];

        // åˆå§‹åŒ–
        function init() {
            // æ³¨å†ŒDataLabelsæ’ä»¶
            Chart.register(ChartDataLabels);

                        parsedData = parseData();
            updateStoreData('ä¾¨åŸ');
        }

        // è§£ææ•°æ®
        function parseData() {
            const lines = storeData.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const record = {};
                headers.forEach((header, index) => {
                    record[header] = values[index];
                });
                data.push(record);
            }

            return data;
        }

        // åˆ‡æ¢é—¨åº—
        function switchStore(store, element) {
            currentStore = store;

            // æ›´æ–°æ ‡ç­¾çŠ¶æ€
            document.querySelectorAll('.store-tab').forEach(tab => tab.classList.remove('active'));
            element.classList.add('active');

            updateStoreData(store);
        }

        
      // æ›´æ–°é—¨åº—æ•°æ®
        function updateStoreData(store) {
            let storeData = parsedData.filter(item => item['é—¨åº—'] === store);

            // ç§»é™¤æ‰“é±¼æ•°æ®çš„24å¹´6-7æœˆï¼ˆæ‰“é±¼é‚€çº¦ä¸º0çš„æœˆä»½ï¼‰
            storeData = storeData.filter(item => {
                const year = parseInt(item['å¹´ä»½']);
                const month = parseInt(item['æœˆä»½']);
                const fishInvite = parseValue(item['æ‰“é±¼é‚€çº¦']);
                return !(year === 2024 && month <= 7 && fishInvite === 0);
            });

            // æ›´æ–°å›¾è¡¨
            updateAllCharts(storeData);
        }


        // æ›´æ–°æ‰€æœ‰å›¾è¡¨
        function updateAllCharts(storeData) {
            const container = document.getElementById('chartsGrid');
            container.innerHTML = '';

            // æ¸…é™¤ä¹‹å‰çš„å›¾è¡¨
            Object.values(charts).forEach(chart => {
                if (chart) chart.destroy();
            });
            charts = {};

            // åˆ›å»ºå›¾è¡¨å¯¼èˆª
            createChartNavigation();

            // åˆ›å»ºå•ä¸ªæŒ‡æ ‡å›¾è¡¨
            indicators.forEach((indicator, index) => {
                createIndicatorChart(container, storeData, indicator, `chart${index}`);

                // ä¸ºè¥æ”¶å’Œç¡®è®¤æ”¶å…¥æ·»åŠ ç°é‡‘æµè¡¨æ ¼
                if (indicator.key === 'æ€»è¥æ”¶' || indicator.key === 'ç¡®è®¤æ”¶å…¥') {
                    // è·å–å¯¹åº”çš„å¹³è¡¡ç‚¹
                    const storeName = storeData.length > 0 ? storeData[0]['é—¨åº—'] : currentStore;
                    let balancePoint = 0;
                    if (storeName === 'å¹³å®‰') {
                        balancePoint = 215000;
                    } else if (storeName === 'ä¾¨åŸ' || storeName === 'åŒçº') {
                        balancePoint = 140000;
                    }

                    // åˆ›å»ºç°é‡‘æµè¡¨æ ¼ï¼ˆç°åœ¨åŒ…å«å›¾è¡¨ï¼‰
                    createCashFlowTable(container, storeData, indicator, balancePoint);
                }
            });

            // åˆ›å»ºè½¬åŒ–ç±»æŒ‡æ ‡å›¾è¡¨
            conversionIndicators.forEach((indicator, index) => {
                createConversionChart(container, storeData, indicator, `conversion${index}`);
            });

            // åˆ›å»ºç»„åˆæŒ‡æ ‡å›¾è¡¨
            createCustomerTypeChart(container, storeData);
            createAClassCombinedChart(container, storeData);
        }

        // åˆ›å»ºå›¾è¡¨å¯¼èˆª
        function createChartNavigation() {
            const navContainer = document.getElementById('navigationList');
            navContainer.innerHTML = '';

            // åŸºç¡€æŒ‡æ ‡å¯¼èˆª
            const basicGroup = document.createElement('div');
            basicGroup.className = 'nav-group';

            const basicTitle = document.createElement('div');
            basicTitle.className = 'nav-group-title';
            basicTitle.textContent = 'åŸºç¡€æŒ‡æ ‡';
            basicGroup.appendChild(basicTitle);

            indicators.forEach((indicator, index) => {
                const navItem = document.createElement('a');
                navItem.className = 'nav-item';
                navItem.href = '#chart' + index;
                navItem.textContent = indicator.label;
                navItem.onclick = function(e) {
                    e.preventDefault();
                    scrollToChart('chart' + index);
                };
                basicGroup.appendChild(navItem);
            });

            navContainer.appendChild(basicGroup);

            // è½¬åŒ–åˆ†æå¯¼èˆª
            const conversionGroup = document.createElement('div');
            conversionGroup.className = 'nav-group';

            const conversionTitle = document.createElement('div');
            conversionTitle.className = 'nav-group-title';
            conversionTitle.textContent = 'è½¬åŒ–åˆ†æ';
            conversionGroup.appendChild(conversionTitle);

            conversionIndicators.forEach((indicator, index) => {
                const navItem = document.createElement('a');
                navItem.className = 'nav-item';
                navItem.href = '#conversion' + index;
                navItem.textContent = indicator.type + 'ç±»è½¬åŒ–åˆ†æ';
                navItem.onclick = function(e) {
                    e.preventDefault();
                    scrollToChart('conversion' + index);
                };
                conversionGroup.appendChild(navItem);
            });

            navContainer.appendChild(conversionGroup);

            // ç»„åˆæŒ‡æ ‡å¯¼èˆª
            const combinedGroup = document.createElement('div');
            combinedGroup.className = 'nav-group';

            const combinedTitle = document.createElement('div');
            combinedTitle.className = 'nav-group-title';
            combinedTitle.textContent = 'ç»„åˆåˆ†æ';
            combinedGroup.appendChild(combinedTitle);

            const customerTypeNav = document.createElement('a');
            customerTypeNav.className = 'nav-item';
            customerTypeNav.href = '#customerTypeChart';
            customerTypeNav.textContent = 'è€å®¢åˆ†æ';
            customerTypeNav.onclick = function(e) {
                e.preventDefault();
                scrollToChart('customerTypeChart');
            };
            combinedGroup.appendChild(customerTypeNav);

            const newCustomerNav = document.createElement('a');
            newCustomerNav.className = 'nav-item';
            newCustomerNav.href = '#aClassCombinedChart';
            newCustomerNav.textContent = 'æ–°å®¢åˆ†æ';
            newCustomerNav.onclick = function(e) {
                e.preventDefault();
                scrollToChart('aClassCombinedChart');
            };
            combinedGroup.appendChild(newCustomerNav);

            navContainer.appendChild(combinedGroup);
        }

        // æ»šåŠ¨åˆ°æŒ‡å®šå›¾è¡¨
        function scrollToChart(chartId) {
            // ç§»é™¤æ‰€æœ‰æ´»è·ƒçŠ¶æ€
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // æ·»åŠ æ´»è·ƒçŠ¶æ€
            const activeItem = document.querySelector(`[href="#${chartId}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }

            // æ»šåŠ¨åˆ°å›¾è¡¨
            let targetElement;

            // å¯¹äºè½¬åŒ–åˆ†æï¼Œå…ˆæŸ¥æ‰¾å­å›¾è¡¨ï¼Œå†æŸ¥æ‰¾ä¸»å›¾è¡¨
            if (chartId.includes('conversion')) {
                targetElement = document.getElementById(chartId + '_conversion') ||
                              document.getElementById(chartId + '_rate') ||
                              document.getElementById(chartId);
            } else {
                targetElement = document.getElementById(chartId);
            }

            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });

                // æ·»åŠ é«˜äº®æ•ˆæœ - å¯¹äºè½¬åŒ–åˆ†æå’Œç»„åˆåˆ†æï¼Œè¦é«˜äº®æ•´ä¸ªç‰¹æ®Šå›¾è¡¨å®¹å™¨
                let chartContainer;
                if (chartId.includes('conversion') || chartId === 'customerTypeChart' || chartId === 'aClassCombinedChart') {
                    chartContainer = targetElement.closest('.special-chart');
                } else {
                    chartContainer = targetElement.closest('.chart-container');
                }

                if (chartContainer) {
                    chartContainer.style.transition = 'transform 0.3s ease';
                    chartContainer.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        chartContainer.style.transform = 'scale(1)';
                    }, 500);
                }
            }
        }

        // åˆ›å»ºè€å®¢åˆ†æå›¾è¡¨
        function createCustomerTypeChart(container, storeData) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container special-chart';

            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">è€å®¢åˆ†æ</div>
                        <div class="chart-subtitle">è€å®¢åŠå„ç±»å®¢æˆ·æ•°é‡èµ°åŠ¿</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="customerTypeChart"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            const ctx = document.getElementById('customerTypeChart').getContext('2d');

            // å‚è€ƒåŸºç¡€æŒ‡æ ‡çš„å¤„ç†æ–¹å¼ï¼Œæ¯ä¸ªæ•°æ®é›†ç‹¬ç«‹å¤„ç†
            const datasets = [];

            customerTypeIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                const borderColor = indicator.color;
                const backgroundColor = indicator.color + '20';

                datasets.push({
                    label: indicator.label,
                    data: values,
                    borderColor: borderColor,
                    backgroundColor: backgroundColor,
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: borderColor,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    tension: 0.2,
                    fill: false
                });
            });

            charts.customerTypeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true, // å¯ç”¨å›¾ä¾‹ï¼Œè®©ç”¨æˆ·å¯ä»¥æ§åˆ¶æ˜¾ç¤º/éšè—
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                },
                                boxWidth: 12,
                                padding: 15,
                                // è‡ªå®šä¹‰å›¾ä¾‹ç”Ÿæˆï¼Œåªæ˜¾ç¤ºä¸»è¦æ•°æ®é›†
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        // åªè¿”å›å‰customerTypeIndicators.lengthä¸ªæ•°æ®é›†ï¼ˆä¸»è¦æ•°æ®é›†ï¼‰
                                        return data.datasets.slice(0, customerTypeIndicators.length).map((dataset, i) => ({
                                            text: dataset.label,
                                            fillStyle: dataset.borderColor,
                                            strokeStyle: dataset.borderColor,
                                            lineWidth: dataset.borderWidth,
                                            pointStyle: 'rectRounded',
                                            hidden: !chart.isDatasetVisible(i),
                                            datasetIndex: i
                                        }));
                                    }
                                    return [];
                                }
                            },
                            // è‡ªå®šä¹‰ç‚¹å‡»å¤„ç†
                            onClick: function(e, legendItem, legend) {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);

                                // åˆ‡æ¢ä¸»æ•°æ®é›†çš„æ˜¾ç¤ºçŠ¶æ€
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;

                                // åŒæ—¶åˆ‡æ¢ç›¸å…³çš„å‚è€ƒçº¿æ•°æ®é›†
                                for (let i = customerTypeIndicators.length; i < chart.data.datasets.length; i++) {
                                    const refMeta = chart.getDatasetMeta(i);
                                    const refDataset = chart.data.datasets[i];
                                    // å‚è€ƒçº¿è·Ÿéšå¯¹åº”çš„ä¸»æ•°æ®é›†çš„çŠ¶æ€
                                    if (refDataset.datasetIndexKey === 'reference' && refDataset.mainDatasetIndex === index) {
                                        refMeta.hidden = meta.hidden;
                                    }
                                }

                                chart.update();
                            }
                        },
                        tooltip: {
                            filter: function(tooltipItem) {
                                // åªæ˜¾ç¤ºå®é™…æ•°æ®ï¼Œéšè—å‚è€ƒçº¿
                                return tooltipItem.datasetIndex < customerTypeIndicators.length;
                            },
                            callbacks: {
                                label: function(context) {
                                    const datasetLabel = context.dataset.label || '';
                                    return `${datasetLabel}: ${formatValue(context.parsed.y, 1)}äºº`;
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // åªæ˜¾ç¤ºå®é™…æ•°æ®é›†çš„æ ‡ç­¾ï¼Œä¸æ˜¾ç¤ºå‚è€ƒçº¿
                                return context.datasetIndex < customerTypeIndicators.length;
                            },
                            color: function(context) {
                                return context.dataset.borderColor;
                            },
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: function(context) {
                                return context.dataset.borderColor;
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                return formatValue(value, 1) + 'äºº';
                            },
                            align: function(context) {
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                const y = dataset.data[dataIndex];
                                const scaledY = chart.scales.y.getPixelForValue(y);

                                // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸ŠåŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                                if (scaledY < chartArea.top + 50) {
                                    return 'bottom';
                                }

                                // æ£€æŸ¥ç›¸é‚»æ•°æ®ç‚¹çš„å€¼ï¼Œé¿å…é‡å 
                                const prevY = dataIndex > 0 ? dataset.data[dataIndex - 1] : null;
                                const nextY = dataIndex < dataset.data.length - 1 ? dataset.data[dataIndex + 1] : null;

                                // å¦‚æœä¸ç›¸é‚»ç‚¹å€¼æ¥è¿‘ï¼Œäº¤æ›¿æ˜¾ç¤ºä½ç½®
                                if (prevY && Math.abs(y - prevY) < (chart.scales.y.max - chart.scales.y.min) * 0.08) {
                                    return dataIndex % 2 === 0 ? 'top' : 'bottom';
                                }

                                return 'top';
                            },
                            offset: 8
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'äººæ•°',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + 'äºº';
                                },
                                font: {
                                    size: 11
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'å˜åŒ–é€Ÿåº¦ (%)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è®¾ç½®åˆç†çš„èŒƒå›´
                            min: -100,
                            max: 100
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });

            // ä¸ºæ¯ä¸ªæ•°æ®é›†æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡
            customerTypeIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                setTimeout(() => {
                    addAnalysisIndicators(charts.customerTypeChart, values, 1, 'äºº', storeData[0]['é—¨åº—'], index);
                }, 100);
            });
        }

        // åˆ›å»ºå•ä¸ªæŒ‡æ ‡å›¾è¡¨
        function createIndicatorChart(container, storeData, indicator, chartId) {
            // æå–é—¨åº—åç§°
            const storeName = storeData.length > 0 ? storeData[0]['é—¨åº—'] : currentStore;
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';

            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);

            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            const values = storeData.map(item => parseValue(item[indicator.key]));
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
            const max = Math.max(...values);
            const min = Math.min(...values);

            // ä¸ºè¥æ”¶å’Œç¡®æ”¶å›¾è¡¨ä½¿ç”¨ä¸åŒé¢œè‰²
            const borderColor = indicator.key === 'æ€»è¥æ”¶' ? 'rgb(102, 126, 234)' :
                             indicator.key === 'ç¡®è®¤æ”¶å…¥' ? 'rgb(255, 99, 132)' : 'rgb(102, 126, 234)';
            const backgroundColor = indicator.key === 'æ€»è¥æ”¶' ? 'rgba(102, 126, 234, 0.1)' :
                                   indicator.key === 'ç¡®è®¤æ”¶å…¥' ? 'rgba(255, 99, 132, 0.1)' : 'rgba(102, 126, 234, 0.1)';

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${indicator.label}</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="${chartId}"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            datasets = [{
                label: indicator.label,
                data: values,
                borderColor: borderColor,
                backgroundColor: backgroundColor,
                borderWidth: 3,
                pointRadius: 5,
                pointBackgroundColor: borderColor,
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                tension: 0.2,
                fill: true
            }];

            // åˆ›å»ºå›¾è¡¨ - åœ¨ä¸¤ä¸ªåˆ†æ”¯ä¹‹å¤–å®šä¹‰ctx
            const ctx = document.getElementById(chartId).getContext('2d');

            charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                        axis: 'x', // å¯ç”¨Xè½´è·Ÿè¸ª
                    },
                    // æ·»åŠ XYè·Ÿè¸ªçº¿é…ç½®
                    plugins: {
                        legend: {
                            display: false, // æ‰€æœ‰å›¾è¡¨éƒ½ä¸æ˜¾ç¤ºå›¾ä¾‹
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            enabled: true, // å¯ç”¨tooltipä»¥æ”¯æŒåå­—çº¿ï¼Œä½†åªæ˜¾ç¤ºå¿…è¦ä¿¡æ¯
                            intersect: false,
                            mode: 'index',
                            backgroundColor: 'rgba(0, 0, 0, 0)',
                            titleColor: 'transparent',
                            bodyColor: 'transparent',
                            borderColor: 'transparent',
                            displayColors: false,
                            callbacks: {
                                title: () => '',
                                label: () => ''
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // æ˜¾ç¤ºæ‰€æœ‰æ•°æ®æ ‡ç­¾ï¼Œä½†ä½¿ç”¨æ›´å°çš„å­—ä½“å’Œæ›´æ™ºèƒ½çš„ä½ç½®
                                return true;
                            },
                            color: '#333',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: 'rgba(0, 0, 0, 0.1)',
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                // å®é™…æ•°æ®ç‚¹å¸¦å•ä½
                                return formatValue(value, indicator.scale) + indicator.unit;
                            },
                            align: function(context) {
                                // æ›´æ™ºèƒ½çš„æ ‡ç­¾ä½ç½®è°ƒæ•´ - é˜²æ­¢é‡å 
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                const y = dataset.data[dataIndex];
                                const scaledY = chart.scales.y.getPixelForValue(y);

                                // è·å–å›¾è¡¨é«˜åº¦
                                const chartHeight = chartArea.bottom - chartArea.top;

                                // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸ŠåŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                                if (scaledY < chartArea.top + chartHeight * 0.3) {
                                    return 'bottom';
                                }

                                // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸‹åŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸Šæ–¹
                                if (scaledY > chartArea.bottom - chartHeight * 0.3) {
                                    return 'top';
                                }

                                // æ£€æŸ¥ç›¸é‚»æ•°æ®ç‚¹çš„å€¼ï¼Œé¿å…é‡å 
                                const prevY = dataIndex > 0 ? dataset.data[dataIndex - 1] : null;
                                const nextY = dataIndex < dataset.data.length - 1 ? dataset.data[dataIndex + 1] : null;
                                const threshold = (chart.scales.y.max - chart.scales.y.min) * 0.08;

                                // å¦‚æœä¸ç›¸é‚»ç‚¹å€¼æ¥è¿‘ï¼Œäº¤æ›¿æ˜¾ç¤ºä½ç½®
                                if (prevY && Math.abs(y - prevY) < threshold) {
                                    return dataIndex % 2 === 0 ? 'top' : 'bottom';
                                }

                                if (nextY && Math.abs(y - nextY) < threshold) {
                                    return dataIndex % 2 === 0 ? 'bottom' : 'top';
                                }

                                // é»˜è®¤æ˜¾ç¤ºåœ¨ä¸Šæ–¹
                                return 'top';
                            },
                            offset: 2,
                            clamp: true, // é˜²æ­¢æ ‡ç­¾è¶…å‡ºcanvasè¾¹ç•Œ
                            // æ—‹è½¬æ ‡ç­¾ä»¥èŠ‚çœç©ºé—´
                            rotation: function(context) {
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const availableWidth = chartArea.width / context.dataset.data.length;

                                // å¦‚æœå¯ç”¨å®½åº¦å¾ˆå°ï¼Œç¨å¾®æ—‹è½¬æ ‡ç­¾
                                if (availableWidth < 40) {
                                    return -10; // è½»å¾®æ—‹è½¬-10åº¦
                                }
                                return 0; // æ°´å¹³æ˜¾ç¤º
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: indicator.key.includes('è½¬åŒ–ç‡'),
                            // å¯¹äºäººå‡æœåŠ¡æ—¶é•¿ï¼Œè®¾ç½®æ›´ç´§å‡‘çš„Yè½´èŒƒå›´ä»¥çªå‡ºè¶‹åŠ¿
                            min: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 1.2 : undefined,
                            max: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 1.7 : undefined,
                            ticks: {
                                callback: function(value) {
                                    return formatValue(value, indicator.scale) + indicator.unit;
                                },
                                // å¯¹äºäººå‡æœåŠ¡æ—¶é•¿ï¼Œè®¾ç½®0.1çš„æ­¥é•¿ä»¥æ˜¾ç¤ºç»†å¾®å˜åŒ–
                                stepSize: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 0.1 : undefined,
                                // ç¡®ä¿æ˜¾ç¤ºå°æ•°ä½
                                precision: indicator.key === 'äººå‡æœåŠ¡æ—¶é•¿' ? 1 : undefined
                            },
                            grid: {
                                display: false
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'å˜åŒ–é€Ÿåº¦ (%)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è®¾ç½®åˆç†çš„èŒƒå›´
                            min: -100,
                            max: 100
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            // æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡ï¼ˆ3ä¸ªæœˆç§»åŠ¨å¹³å‡å’Œå˜åŒ–é€Ÿåº¦ï¼‰
            setTimeout(() => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                addAnalysisIndicators(charts[chartId], values, indicator.scale, indicator.unit, storeName);

                // ä¸ºè¥æ”¶å’Œç¡®æ”¶å›¾è¡¨æ·»åŠ hoveräº‹ä»¶ç›‘å¬å’Œåå­—çº¿
                if (indicator.key === 'æ€»è¥æ”¶' || indicator.key === 'ç¡®è®¤æ”¶å…¥') {
                    const chart = charts[chartId];
                    let crosshairCanvas = null;

                    // åˆ›å»ºåå­—çº¿ç”»å¸ƒ
                    function createCrosshairCanvas() {
                        crosshairCanvas = document.createElement('canvas');
                        crosshairCanvas.style.position = 'absolute';
                        crosshairCanvas.style.top = '0';
                        crosshairCanvas.style.left = '0';
                        crosshairCanvas.style.pointerEvents = 'none';
                        crosshairCanvas.style.zIndex = '1000';

                        const canvasRect = chart.canvas.getBoundingClientRect();
                        crosshairCanvas.width = canvasRect.width;
                        crosshairCanvas.height = canvasRect.height;

                        chart.canvas.parentElement.style.position = 'relative';
                        chart.canvas.parentElement.appendChild(crosshairCanvas);
                    }

                    // ç»˜åˆ¶åå­—çº¿
                    function drawCrosshair(mouseX, mouseY) {
                        if (!crosshairCanvas) return;

                        const ctx = crosshairCanvas.getContext('2d');
                        const canvasRect = chart.canvas.getBoundingClientRect();

                        // æ¸…é™¤ç”»å¸ƒ
                        ctx.clearRect(0, 0, crosshairCanvas.width, crosshairCanvas.height);

                        // è·å–å›¾è¡¨åŒºåŸŸ
                        const chartArea = chart.chartArea;
                        const scaleX = crosshairCanvas.width / (canvasRect.width);
                        const scaleY = crosshairCanvas.height / (canvasRect.height);

                        const chartLeft = chartArea.left * scaleX;
                        const chartRight = chartArea.right * scaleX;
                        const chartTop = chartArea.top * scaleY;
                        const chartBottom = chartArea.bottom * scaleY;

                        ctx.save();
                        ctx.strokeStyle = 'rgba(128, 128, 128, 0.9)'; // æ·±ç°è‰²
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 4]);

                        // ç»˜åˆ¶å‚ç›´çº¿
                        ctx.beginPath();
                        ctx.moveTo(mouseX, chartTop);
                        ctx.lineTo(mouseX, chartBottom);
                        ctx.stroke();

                        // ç»˜åˆ¶æ°´å¹³çº¿
                        ctx.beginPath();
                        ctx.moveTo(chartLeft, mouseY);
                        ctx.lineTo(chartRight, mouseY);
                        ctx.stroke();

                        ctx.restore();
                    }

                    // æ¸…é™¤åå­—çº¿
                    function clearCrosshair() {
                        if (crosshairCanvas) {
                            const ctx = crosshairCanvas.getContext('2d');
                            ctx.clearRect(0, 0, crosshairCanvas.width, crosshairCanvas.height);
                        }
                    }

                    // å»¶è¿Ÿåˆ›å»ºåå­—çº¿ç”»å¸ƒï¼Œç¡®ä¿å›¾è¡¨å·²å®Œå…¨æ¸²æŸ“
                    setTimeout(() => {
                        createCrosshairCanvas();
                    }, 200);

                    // é¼ æ ‡è¿›å…¥äº‹ä»¶
                    chart.canvas.addEventListener('mousemove', function(event) {
                        const rect = chart.canvas.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;

                        const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                        const dataIndex = Math.round(dataX);

                        // ç»˜åˆ¶åå­—çº¿
                        drawCrosshair(x, y);

                        if (dataIndex >= 0 && dataIndex < storeData.length) {
                            // æ›´æ–°å¯¹åº”çš„ç°é‡‘æµè¡¨æ ¼
                            updateCashFlowTable(storeData, indicator, dataIndex);

                            // æ˜¾ç¤ºæ‚¬æµ®ä¿¡æ¯æ¡†
                            showHoverInfo(event, storeData, dataIndex, indicator);
                        }
                    });

                    // é¼ æ ‡ç¦»å¼€äº‹ä»¶ - æ¢å¤é»˜è®¤æ˜¾ç¤º
                    chart.canvas.addEventListener('mouseleave', function() {
                        // æ¸…é™¤åå­—çº¿
                        clearCrosshair();

                        // æ¢å¤é»˜è®¤çš„ç°é‡‘æµè¡¨æ ¼ï¼ˆæœ€æ–°æœˆä»½ï¼‰
                        setTimeout(() => {
                            const latestIndex = storeData.length - 1;
                            updateCashFlowTable(storeData, indicator, latestIndex);
                        }, 100); // ç¨å¾®å»¶è¿Ÿï¼Œé¿å…é—ªçƒ

                        // éšè—æ‚¬æµ®ä¿¡æ¯æ¡†
                        hideHoverInfo();
                    });
                }
            }, 150);
        }

        // è½¬åŒ–ç‡ç›®æ ‡å€¼é…ç½®
        function getTargetValues(conversionType) {
            const targets = {
                'A': { pass: 20, excellent: 30 },
                'B': { pass: 50, excellent: 80 },
                'C': { pass: 50, excellent: 80 }, // ä¸Bç±»ç›¸åŒ
                'D': { pass: null, excellent: null } // Dç±»ä¸æ˜¾ç¤ºç›®æ ‡çº¿
            };
            return targets[conversionType] || { pass: null, excellent: null };
        }

        // åˆ›å»ºè½¬åŒ–ç±»æŒ‡æ ‡å›¾è¡¨
        function createConversionChart(container, storeData, indicator, chartId) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container special-chart';

            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);
            const denomData = storeData.map(item => parseValue(item[indicator.denomKey])); // è½¬åŒ–åˆ†æ¯
            const numData = storeData.map(item => parseValue(item[indicator.numKey]));     // è½¬åŒ–æ•°
            const rateData = storeData.map(item => parseValue(item[indicator.rateKey]));     // è½¬åŒ–ç‡

            // è®¡ç®—è½¬åŒ–ç‡çš„ç»Ÿè®¡
            const avgRate = rateData.reduce((sum, val) => sum + val, 0) / rateData.length;
            const maxRate = Math.max(...rateData);
            const minRate = Math.min(...rateData);

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${indicator.type}ç±»è½¬åŒ–åˆ†æ</div>
                        <div class="chart-subtitle">è½¬åŒ–ç‡å¹³å‡: ${avgRate.toFixed(1)}% | æœ€å¤§: ${maxRate.toFixed(1)}% | æœ€å°: ${minRate.toFixed(1)}%</div>
                    </div>
                </div>

                <!-- ä¸ŠåŠéƒ¨åˆ†ï¼šè½¬åŒ–å¯¹æ¯”å›¾è¡¨ï¼ˆæŸ±çŠ¶å›¾+æŠ˜çº¿å›¾ï¼‰ -->
                <div class="chart-subsection">
                    <div class="chart-wrapper-small">
                        <canvas id="${chartId}_conversion"></canvas>
                    </div>
                </div>

                <!-- ä¸‹åŠéƒ¨åˆ†ï¼šè½¬åŒ–ç‡è¶‹åŠ¿å›¾è¡¨ -->
                <div class="chart-subsection">
                    <div class="chart-wrapper-small rate-chart">
                        <canvas id="${chartId}_rate"></canvas>
                    </div>
                </div>
            `;

            container.appendChild(chartContainer);

            // åˆ›å»ºä¸ŠåŠéƒ¨åˆ†å›¾è¡¨ï¼šè½¬åŒ–æ•°ï¼ˆæŠ˜çº¿å›¾ï¼‰+ è½¬åŒ–åˆ†æ¯ï¼ˆæŸ±çŠ¶å›¾ï¼‰
            const ctxConversion = document.getElementById(`${chartId}_conversion`).getContext('2d');
            charts[`${chartId}_conversion`] = new Chart(ctxConversion, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        // è½¬åŒ–åˆ†æ¯ - æŸ±çŠ¶å›¾ï¼ˆåº•å±‚ï¼‰
                        {
                            label: 'è½¬åŒ–åˆ†æ¯',
                            data: denomData,
                            backgroundColor: '#87CEEB', // å¤©è“è‰²
                            borderColor: '#4682B4',      // é’¢è“è‰²
                            borderWidth: 1,
                            order: 2,
                            yAxisID: 'y'
                        },
                        // è½¬åŒ–æ•° - æŠ˜çº¿å›¾ï¼ˆé¡¶å±‚ï¼‰
                        {
                            label: 'è½¬åŒ–æ•°',
                            data: numData,
                            borderColor: indicator.color,
                            backgroundColor: indicator.color + '20',
                            borderWidth: 3,
                            fill: false,
                            type: 'line',
                            tension: 0.3,
                            pointRadius: 5,
                            pointBackgroundColor: indicator.color,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            pointHoverRadius: 7,
                            order: 1,
                            yAxisID: 'y1' // ä½¿ç”¨å³ä¾§Yè½´
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    if (context.datasetIndex === 0) {
                                        return `è½¬åŒ–åˆ†æ¯: ${context.parsed.y}äºº`;
                                    } else {
                                        return [
                                            `è½¬åŒ–æ•°: ${context.parsed.y}äºº`,
                                            `è½¬åŒ–ç‡: ${rateData[dataIndex].toFixed(1)}%`
                                        ];
                                    }
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // æ˜¾ç¤ºæ‰€æœ‰æ ‡ç­¾ï¼ŒåŒ…æ‹¬0å€¼ï¼Œä½†ä¼šè°ƒæ•´ä½ç½®é¿å…é®æŒ¡
                                return true;
                            },
                            color: function(context) {
                                // è½¬åŒ–åˆ†æ¯ç”¨è“è‰²ï¼Œè½¬åŒ–æ•°ç”¨å½©è‰²
                                return context.datasetIndex === 0 ? '#4682B4' : indicator.color;
                            },
                            font: {
                                size: 8,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: function(context) {
                                return context.datasetIndex === 0 ? '#4682B4' : indicator.color;
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                // ç¡®ä¿äººæ•°æ˜¾ç¤ºä¸ºæ•´æ•°ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
                                return Math.round(value) + 'äºº';
                            },
                            anchor: 'end',
                            align: function(context) {
                                const dataIndex = context.dataIndex;
                                const denomValue = denomData[dataIndex]; // è½¬åŒ–åˆ†æ¯
                                const numValue = numData[dataIndex];    // è½¬åŒ–æ•°
                                const currentDataset = context.dataset.data[dataIndex];

                                // è®¡ç®—æ•°å€¼æ¥è¿‘ç¨‹åº¦ï¼ˆ30%ä»¥å†…æˆ–ç»å¯¹å€¼å·®å°äº3äººè®¤ä¸ºæ¥è¿‘ï¼‰
                                const isClose = Math.abs(denomValue - numValue) / Math.max(denomValue, numValue) < 0.3 ||
                                               Math.abs(denomValue - numValue) < 3;

                                if (context.datasetIndex === 0) { // è½¬åŒ–åˆ†æ¯ï¼ˆæŸ±çŠ¶å›¾ï¼‰
                                    if (currentDataset === 0) {
                                        return 'bottom'; // 0å€¼æ˜¾ç¤ºåœ¨æŸ±åº•ï¼Œé¿å…è¦†ç›–æœˆä»½
                                    } else {
                                        return 'top'; // éé›¶å€¼æ˜¾ç¤ºåœ¨æŸ±é¡¶
                                    }
                                } else { // è½¬åŒ–æ•°ï¼ˆæŠ˜çº¿å›¾ï¼‰
                                    if (currentDataset === 0) {
                                        return 'bottom'; // 0å€¼æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸‹æ–¹
                                    } else if (isClose) {
                                        return 'bottom'; // æ•°å€¼æ¥è¿‘æ—¶æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸‹æ–¹ï¼Œé¿å…é‡å 
                                    } else {
                                        return 'top'; // æ•°å€¼ä¸æ¥è¿‘æ—¶æ­£å¸¸æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸Šæ–¹
                                    }
                                }
                            },
                            offset: function(context) {
                                const dataIndex = context.dataIndex;
                                const denomValue = denomData[dataIndex]; // è½¬åŒ–åˆ†æ¯
                                const numValue = numData[dataIndex];    // è½¬åŒ–æ•°
                                const currentDataset = context.dataset.data[dataIndex];

                                // è®¡ç®—æ•°å€¼æ¥è¿‘ç¨‹åº¦ï¼ˆ30%ä»¥å†…æˆ–ç»å¯¹å€¼å·®å°äº3äººè®¤ä¸ºæ¥è¿‘ï¼‰
                                const isClose = Math.abs(denomValue - numValue) / Math.max(denomValue, numValue) < 0.3 ||
                                               Math.abs(denomValue - numValue) < 3;

                                if (context.datasetIndex === 0) { // è½¬åŒ–åˆ†æ¯
                                    if (currentDataset === 0) {
                                        return -3; // 0å€¼æ˜¾ç¤ºåœ¨æŸ±åº•ä¸‹æ–¹ï¼Œé¿å…è¦†ç›–æœˆä»½
                                    } else {
                                        return 2; // éé›¶å€¼æ˜¾ç¤ºåœ¨æŸ±é¡¶ä¸Šæ–¹ä¸€ç‚¹
                                    }
                                } else { // è½¬åŒ–æ•°
                                    if (currentDataset === 0) {
                                        return 8; // 0å€¼æ˜¾ç¤ºåœ¨æŠ˜çº¿ä¸‹æ–¹
                                    } else if (isClose) {
                                        return 10; // æ•°å€¼æ¥è¿‘æ—¶ï¼Œåœ¨æŠ˜çº¿ä¸‹æ–¹æ›´è¿œå¤„ï¼Œå®Œå…¨é”™å¼€
                                    } else {
                                        return 5; // æ•°å€¼ä¸æ¥è¿‘æ—¶ï¼Œåœ¨æŠ˜çº¿ä¸Šæ–¹æ­£å¸¸è·ç¦»
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'è½¬åŒ–åˆ†æ¯ï¼ˆäººï¼‰',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return Math.round(value) + 'äºº';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è°ƒæ•´å·¦ä¾§Yè½´èŒƒå›´ï¼Œç»™æ•°å€¼ç•™æ›´å¤šç©ºé—´
                            max: Math.max(...denomData) * 1.3
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'è½¬åŒ–æ•°ï¼ˆäººï¼‰',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return Math.round(value) + 'äºº';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // é’ˆå¯¹ä¸åŒè½¬åŒ–ç±»å‹è°ƒæ•´å³ä¾§Yè½´èŒƒå›´
                            max: function() {
                                const numMax = Math.max(...numData);
                                const denomMax = Math.max(...denomData);

                                // å¯¹äºä¸åŒè½¬åŒ–ç±»å‹ï¼Œè®¾ç½®ä¸åŒçš„Yè½´èŒƒå›´
                                if (indicator.type === 'A') {
                                    // Aç±»ï¼šå³ä¾§Yè½´èŒƒå›´å›ºå®šä¸º0-15
                                    return 15;
                                } else if (indicator.type === 'D') {
                                    // Dç±»ï¼šå³ä¾§Yè½´èŒƒå›´å›ºå®šä¸º0-25ï¼Œè®©åˆ†å­è¶‹åŠ¿æ›´æ˜æ˜¾
                                    return 25;
                                } else {
                                    // Bç±»å’ŒCç±»ï¼šä¿æŒåŸæœ‰é€»è¾‘
                                    return Math.max(numMax, denomMax) * 1.2;
                                }
                            }()
                        }
                    }
                }
            });

            // åˆ›å»ºä¸‹åŠéƒ¨åˆ†å›¾è¡¨ï¼šè½¬åŒ–ç‡è¶‹åŠ¿
            const ctxRate = document.getElementById(`${chartId}_rate`).getContext('2d');

            // è·å–ç›®æ ‡å€¼
            const targetValues = getTargetValues(indicator.type);

            // åŠ¨æ€æ„å»ºæ•°æ®é›†
            const datasets = [
                {
                    label: 'è½¬åŒ–ç‡',
                    data: rateData,
                    borderColor: '#ff6b6b',
                    backgroundColor: '#ff6b6b20',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.3,
                    pointRadius: 5,
                    pointBackgroundColor: '#ff6b6b',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 7,
                    order: 1
                }
            ];

            // åªæœ‰å½“æœ‰ç›®æ ‡å€¼æ—¶æ‰æ·»åŠ å‚è€ƒçº¿
            if (targetValues.excellent !== null && targetValues.excellent > 0) {
                datasets.push({
                    label: 'ä¼˜ç§€å€¼',
                    data: new Array(rateData.length).fill(targetValues.excellent),
                    borderColor: '#27ae60',
                    borderWidth: 2,
                    borderDash: [8, 4],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                    order: 2,
                    datalabels: {
                        display: function(context) {
                            return context.dataIndex === rateData.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                        },
                        align: 'left',
                        anchor: 'center',
                        offset: 8,
                        color: '#27ae60',
                        font: {
                            size: 10,
                            weight: 'bold'
                        },
                        formatter: function() {
                            return `ä¼˜ç§€: ${targetValues.excellent}%`;
                        }
                    }
                });
            }

            if (targetValues.pass !== null && targetValues.pass > 0) {
                datasets.push({
                    label: 'åŠæ ¼å€¼',
                    data: new Array(rateData.length).fill(targetValues.pass),
                    borderColor: '#f39c12',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                    order: 2,
                    datalabels: {
                        display: function(context) {
                            return context.dataIndex === rateData.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                        },
                        align: 'left',
                        anchor: 'center',
                        offset: 8,
                        color: '#f39c12',
                        font: {
                            size: 10,
                            weight: 'bold'
                        },
                        formatter: function() {
                            return `åŠæ ¼: ${targetValues.pass}%`;
                        }
                    }
                });
            }

            charts[`${chartId}_rate`] = new Chart(ctxRate, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    return [
                                        `è½¬åŒ–ç‡: ${context.parsed.y.toFixed(1)}%`,
                                        `è½¬åŒ–æ•°: ${numData[dataIndex]}äºº / åˆ†æ¯: ${denomData[dataIndex]}äºº`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: '#ff6b6b',
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                return value.toFixed(1) + '%';
                            },
                            anchor: 'end',
                            align: 'top',
                            offset: 3
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'è½¬åŒ–ç‡ (%)',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            max: Math.max(targetValues.excellent, Math.max(...rateData)) * 1.2
                        }
                    }
                }
            });
        }


        // æ·»åŠ åªæœ‰å¹³å‡å€¼çš„å‚è€ƒçº¿
        function addSimpleAverageLine(chart, values, color, label, datasetIndex) {
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;

            // ä¿®å¤æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
            const fixedAvg = (Math.abs(avg - Math.round(avg)) < 0.000001) ? Math.round(avg) : avg;

            chart.data.datasets.push({
                label: `${label}å¹³å‡`,
                data: new Array(values.length).fill(fixedAvg),
                borderColor: color,
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                datalabels: {
                    display: function(context) {
                        return context.dataIndex === values.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                    },
                    align: 'left',
                    anchor: 'center',
                    offset: function(context) {
                        // æ™ºèƒ½è°ƒæ•´åç§»é‡ï¼Œé¿å…é‡å 
                        const datasetIndex = context.datasetIndex;
                        const baseOffset = 8;

                        // æ ¹æ®æ•°æ®é›†æ•°é‡å’Œç´¢å¼•åŠ¨æ€è°ƒæ•´é—´è·
                        const smartSpacing = Math.max(12, Math.min(18, 8 + datasetIndex * 10));

                        // å¦‚æœæ˜¯å¤šä¸ªæ•°æ®é›†ï¼Œå‡å°‘é—´è·é¿å…è¿‡åº¦åˆ†æ•£
                        return baseOffset + (datasetIndex * smartSpacing);
                    },
                    color: color,
                    font: {
                        size: 10,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                    borderColor: color,
                    borderWidth: 1,
                    borderRadius: 3,
                    padding: 2,
                    formatter: function() {
                        return `å¹³å‡: ${fixedAvg}äºº`;
                    }
                }
            });

            chart.update();
        }

        // ä¸ºæ•°æ®é›†æ·»åŠ å‚è€ƒçº¿ï¼ˆåªæ˜¾ç¤ºå¹³å‡å€¼ï¼‰
        // æ·»åŠ å‚è€ƒçº¿ï¼Œä½¿ç”¨æ•°æ®é›†çš„é¢œè‰²
        function addReferenceLinesForDataset(chart, values, scale, unit, storeName, datasetCount, lineColor = '#27ae60') {
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;

            // ä¿®å¤å°æ•°ç‚¹æ˜¾ç¤ºé—®é¢˜ï¼Œä¿ç•™1ä½å°æ•°
            const fixedAvg = Math.round(avg * 10) / 10;

            chart.data.datasets.push({
                label: 'å¹³å‡',
                data: new Array(values.length).fill(fixedAvg),
                borderColor: lineColor,
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                // æ·»åŠ è¿™ä¸ªå±æ€§æ¥éšè—tooltip
                parsing: {
                    yAxisKey: 'y'
                },
                // éšè—åœ¨tooltipä¸­
                order: 99,
                datalabels: {
                    display: function(context) {
                        return context.dataIndex === values.length - 1; // åªåœ¨æœ€åä¸€ä¸ªç‚¹æ˜¾ç¤º
                    },
                    align: 'left',
                    anchor: 'center',
                    offset: function(context) {
                        // æ™ºèƒ½è°ƒæ•´åç§»é‡ï¼Œé¿å…é‡å 
                        const datasetIndex = context.datasetIndex;
                        const baseOffset = 8;

                        // æ ¹æ®æ•°æ®é›†æ•°é‡å’Œç´¢å¼•åŠ¨æ€è°ƒæ•´é—´è·
                        const smartSpacing = Math.max(12, Math.min(18, 8 + datasetIndex * 10));

                        // å¦‚æœæ˜¯å¤šä¸ªæ•°æ®é›†ï¼Œå‡å°‘é—´è·é¿å…è¿‡åº¦åˆ†æ•£
                        return baseOffset + (datasetIndex * smartSpacing);
                    },
                    color: lineColor,
                    font: {
                        size: 10,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: lineColor,
                    borderWidth: 1,
                    borderRadius: 3,
                    padding: 2,
                    formatter: function() {
                        return `å¹³å‡: ${fixedAvg}äºº`;
                    }
                }
            });

            chart.update();
        }

        // è®¡ç®—3ä¸ªæœˆç§»åŠ¨å¹³å‡å€¼
        function calculateMovingAverage(values, windowSize = 3) {
            const result = [];
            for (let i = 0; i < values.length; i++) {
                if (i < windowSize - 1) {
                    result.push(null); // å‰å‡ ä¸ªæœˆæ²¡æœ‰è¶³å¤Ÿæ•°æ®
                } else {
                    const sum = values.slice(i - windowSize + 1, i + 1).reduce((a, b) => a + b, 0);
                    result.push(sum / windowSize);
                }
            }
            return result;
        }

        // è®¡ç®—å˜åŒ–é€Ÿåº¦ï¼ˆ3ä¸ªæœˆç§»åŠ¨å¹³å‡çš„æ–œç‡ï¼‰
        function calculateChangeRate(values, windowSize = 3) {
            const movingAvg = calculateMovingAverage(values, windowSize);
            const result = [];

            for (let i = 0; i < movingAvg.length; i++) {
                if (i < windowSize || movingAvg[i] === null || movingAvg[i - windowSize] === null) {
                    result.push(null);
                } else {
                    const change = movingAvg[i] - movingAvg[i - windowSize];
                    const rate = (change / movingAvg[i - windowSize]) * 100;
                    result.push(rate);
                }
            }
            return result;
        }

        // æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡åˆ°å›¾è¡¨
        function addAnalysisIndicators(chart, values, scale, unit, storeName = null, mainDatasetIndex = null) {
            // è·å–å›¾è¡¨æ ‡ç­¾ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºè¥æ”¶æˆ–ç¡®æ”¶å›¾è¡¨
            const chartLabel = chart.data.datasets[0].label;
            const isRevenueChart = chartLabel === 'æ€»è¥æ”¶' || chartLabel === 'ç¡®è®¤æ”¶å…¥';

            // è·å–å½“å‰é—¨åº—ï¼Œè®¾ç½®ç›ˆäºå¹³è¡¡ç‚¹
            const currentStoreName = storeName || currentStore;
            let breakevenPoint = 0;

            if (chartLabel === 'æ€»è¥æ”¶' || chartLabel === 'ç¡®è®¤æ”¶å…¥') {
                if (currentStoreName === 'å¹³å®‰') {
                    breakevenPoint = 215000;
                } else if (currentStoreName === 'ä¾¨åŸ' || currentStoreName === 'åŒçº') {
                    breakevenPoint = 140000;
                }
            }

            // è®¡ç®—3ä¸ªæœˆç§»åŠ¨å¹³å‡
            const movingAvgValues = calculateMovingAverage(values, 3);

            // è®¡ç®—å˜åŒ–é€Ÿåº¦
            const changeRateValues = calculateChangeRate(values, 3);

            // è®¡ç®—ç§»åŠ¨å¹³å‡çº¿çš„æ–œç‡ç™¾åˆ†æ¯”ï¼ˆç›¸å¯¹äºä¸Šæœˆçš„ç™¾åˆ†æ¯”å˜åŒ–ï¼‰
            const movingAvgChangeRates = [];
            for (let i = 1; i < movingAvgValues.length; i++) {
                if (movingAvgValues[i-1] !== null && movingAvgValues[i] !== null && movingAvgValues[i-1] !== 0) {
                    const changeRate = ((movingAvgValues[i] - movingAvgValues[i-1]) / movingAvgValues[i-1]) * 100;
                    movingAvgChangeRates.push(changeRate);
                } else {
                    movingAvgChangeRates.push(null);
                }
            }
            movingAvgChangeRates.unshift(null); // ç¬¬ä¸€ä¸ªæœˆæ²¡æœ‰å˜åŒ–ç‡

            // æ™ºèƒ½æ ‡ç­¾åç§»è®¡ç®— - é¿å…é‡å 
            function calculateSmartOffset(context, baseOffset, labelType) {
                const dataIndex = context.dataIndex;
                const chart = context.chart;
                const datasets = chart.data.datasets;

                // è·å–å½“å‰ç‚¹çš„ä½ç½®
                const datasetIndex = context.datasetIndex;
                const meta = chart.getDatasetMeta(datasetIndex);
                if (!meta || !meta.data[dataIndex]) return baseOffset;

                const point = meta.data[dataIndex];
                const y = point.y;

                // è®¡ç®—åŠ¨æ€åç§»
                let smartOffset = baseOffset;

                if (labelType === 'movingAvg') {
                    // ç§»åŠ¨å¹³å‡æ ‡ç­¾çš„æ™ºèƒ½åç§»
                    if (dataIndex > 0) {
                        const prevValue = movingAvgValues[dataIndex - 1];
                        const currValue = movingAvgValues[dataIndex];

                        // å¦‚æœæ•°å€¼å˜åŒ–å¾ˆå¤§ï¼Œå¢åŠ é—´è·
                        if (prevValue !== null && currValue !== null) {
                            const changePercent = Math.abs((currValue - prevValue) / prevValue);
                            if (changePercent > 0.3) {
                                smartOffset -= 5; // å˜åŒ–å¤§æ—¶ï¼Œå‡å°‘é—´è·é¿å…åˆ†ç¦»å¤ªè¿œ
                            } else if (changePercent < 0.05) {
                                smartOffset += 3; // å˜åŒ–å°æ—¶ï¼Œå¢åŠ é—´è·é¿å…é‡å 
                            }
                        }
                    }
                } else if (labelType === 'slope') {
                    // æ–œç‡æ ‡ç­¾çš„æ™ºèƒ½åç§» - åŸºäºç§»åŠ¨å¹³å‡æ ‡ç­¾çš„ä½ç½®
                    smartOffset = 18; // åŸºç¡€é—´è·

                    // æ ¹æ®æ•°å€¼å¤§å°å¾®è°ƒ
                    const value = movingAvgValues[dataIndex];
                    if (value !== null) {
                        if (scale === 10000 && value > 150000) {
                            smartOffset += 3; // å¤§æ•°å€¼æ—¶å¢åŠ é—´è·
                        } else if (scale === 1 && value > 100) {
                            smartOffset += 2;
                        }
                    }
                }

                return smartOffset;
            }

            // æ·»åŠ 3ä¸ªæœˆç§»åŠ¨å¹³å‡çº¿æ•°å€¼æ ‡ç­¾ï¼ˆç¬¬ä¸€è¡Œï¼‰
            chart.data.datasets.push({
                label: '3ä¸ªæœˆç§»åŠ¨å¹³å‡',
                data: movingAvgValues,
                borderColor: '#27ae60',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true,
                datasetIndexKey: 'reference',
                mainDatasetIndex: mainDatasetIndex,
                datalabels: {
                    display: function(context) {
                        return movingAvgValues[context.dataIndex] !== null;
                    },
                    align: 'top',
                    anchor: 'end',
                    offset: function(context) {
                        return calculateSmartOffset(context, -12, 'movingAvg');
                    },
                    color: '#27ae60',
                    font: {
                        size: 9,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#27ae60',
                    borderWidth: 1,
                    borderRadius: 3,
                    padding: 2,
                    formatter: function(value, context) {
                        return `${formatValue(value, scale)}${unit}`;
                    }
                }
            });

            // æ·»åŠ ç§»åŠ¨å¹³å‡æ–œç‡æ ‡ç­¾ï¼ˆç¬¬äºŒè¡Œï¼Œå¸¦é¢œè‰²ï¼‰
            chart.data.datasets.push({
                label: 'ç§»åŠ¨å¹³å‡æ–œç‡',
                data: movingAvgValues,
                borderColor: 'transparent',
                pointRadius: 0,
                fill: false,
                tension: 0,
                hiddenInLegend: true,
                datasetIndexKey: 'reference',
                mainDatasetIndex: mainDatasetIndex,
                datalabels: {
                    display: function(context) {
                        const dataIndex = context.dataIndex;
                        return movingAvgValues[dataIndex] !== null && movingAvgChangeRates[dataIndex] !== null;
                    },
                    align: 'bottom',
                    anchor: 'end',
                    offset: function(context) {
                        return calculateSmartOffset(context, 18, 'slope');
                    },
                    color: function(context) {
                        const dataIndex = context.dataIndex;
                        const slopeRate = movingAvgChangeRates[dataIndex];
                        return slopeRate > 0 ? '#e74c3c' : '#27ae60';
                    },
                    font: {
                        size: 8,
                        weight: 'bold'
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: function(context) {
                        const dataIndex = context.dataIndex;
                        const slopeRate = movingAvgChangeRates[dataIndex];
                        return slopeRate > 0 ? '#e74c3c' : '#27ae60';
                    },
                    borderWidth: 1,
                    borderRadius: 2,
                    padding: 1,
                    formatter: function(value, context) {
                        const dataIndex = context.dataIndex;
                        const slopeRate = movingAvgChangeRates[dataIndex];
                        if (slopeRate !== null) {
                            const arrow = slopeRate > 0 ? 'â†—' : 'â†˜';
                            return `${arrow} ${Math.abs(slopeRate).toFixed(1)}%`;
                        }
                        return '';
                    }
                }
            });


            // è®¡ç®—ç§»åŠ¨å¹³å‡çº¿çš„æ–œç‡ï¼ˆè¶‹åŠ¿åˆ¤æ–­ï¼‰
            function calculateMovingAverageSlope(movingAvgValues) {
                const slopes = [];
                for (let i = 1; i < movingAvgValues.length; i++) {
                    if (movingAvgValues[i] !== null && movingAvgValues[i-1] !== null) {
                        // æ–œç‡ = (å½“å‰å€¼ - å‰å€¼) / æ—¶é—´é—´éš”ï¼ˆ1ä¸ªæœˆï¼‰
                        const slope = movingAvgValues[i] - movingAvgValues[i-1];
                        slopes.push(slope);
                    } else {
                        slopes.push(0);
                    }
                }
                slopes.unshift(0); // ç¬¬ä¸€ä¸ªæœˆæ–œç‡ä¸º0
                return slopes;
            }

            // è®¡ç®—ç§»åŠ¨å¹³å‡æ–œç‡
            const movingAvgSlopes = calculateMovingAverageSlope(movingAvgValues);

            // åŸºäºæœ€æ–°ä¸€ä¸ªæœˆçš„ç§»åŠ¨å¹³å‡æ–œç‡åˆ¤æ–­è¶‹åŠ¿
            const latestSlope = movingAvgSlopes[movingAvgSlopes.length - 1];
            const prevSlope = movingAvgSlopes.length > 1 ? movingAvgSlopes[movingAvgSlopes.length - 2] : 0;

            // åˆ¤æ–­è¶‹åŠ¿ï¼ˆè€ƒè™‘æ–œç‡å¤§å°å’Œæ–¹å‘å˜åŒ–ï¼‰
            let trend = '';
            let trendColor = '';

            if (latestSlope > 0) {
                trend = 'â†— ä¸Šå‡';
                trendColor = '#27ae60';
            } else if (latestSlope < 0) {
                trend = 'â†˜ ä¸‹é™';
                trendColor = '#e74c3c';
            } else {
                trend = 'â†’ å¹³ç¨³';
                trendColor = '#f39c12';
            }


            // æ ¹æ®å›¾è¡¨ç±»å‹å†³å®šæ˜¯å¦æ·»åŠ ç›ˆäºå¹³è¡¡ç‚¹çº¿
            if (isRevenueChart) {
                const balanceLabel = chartLabel === 'æ€»è¥æ”¶' ? 'æ”¶æ”¯å¹³è¡¡çº¿' : 'ç›ˆäºå¹³è¡¡çº¿';
                chart.data.datasets.push({
                    label: '', // ç©ºæ ‡ç­¾ç¡®ä¿ä¸ä¼šåœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
                    data: new Array(values.length).fill(breakevenPoint),
                    borderColor: '#f39c12',
                    borderWidth: 2,
                    borderDash: [8, 4],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤ºï¼Œä½†çº¿æ¡å¯è§
                    datalabels: {
                        display: function(context) {
                            return context.dataIndex === values.length - 1;
                        },
                        align: 'left',
                        anchor: 'start',
                        offset: 0,
                        color: '#f39c12',
                        font: {
                            size: 9,
                            weight: 'bold'
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.8)',
                        borderRadius: 3,
                        padding: 1,
                        formatter: function() {
                            return `${balanceLabel}: ${formatValue(breakevenPoint, scale)}${unit}`;
                        }
                    }
                });
            }

            chart.update();
        }

        // è®¡ç®—ç°é‡‘æµæŒ‡æ ‡
        // åŠ¨æ€è®¡ç®—åŸºäºæŒ‡å®šæœˆä»½çš„ç°é‡‘æµæ•°æ®
        function calculateDynamicCashFlow(storeData, indicatorKey, balancePoint, targetIndex) {
            const result = {
                monthly: [],
                quarterly: [],
                semiAnnual: [],
                ninthMonths: [], // æ·»åŠ 9ä¸ªæœˆæ•°æ®æ•°ç»„
                annual: []
            };

            // è®¡ç®—æŒ‡å®šæœˆä»½çš„ç°é‡‘æµ
            result.monthly = storeData.map((item, index) => {
                if (index === targetIndex) {
                    const value = parseValue(item[indicatorKey]);
                    return value - balancePoint;
                }
                return null;
            });

            // è®¡ç®—åŸºäºæŒ‡å®šæœˆä»½çš„å‘¨æœŸç°é‡‘æµ
            function calculatePeriodCashFlowFromTarget(periodMonths, targetIndex) {
                const periodResult = [];
                for (let i = 0; i < storeData.length; i++) {
                    if (i === targetIndex && targetIndex >= periodMonths - 1) {
                        // ä»ç›®æ ‡æœˆä»½å¾€å‰æ¨periodMonthsä¸ªæœˆ
                        let revenueSum = 0;
                        for (let j = targetIndex - periodMonths + 1; j <= targetIndex; j++) {
                            revenueSum += parseValue(storeData[j][indicatorKey]);
                        }
                        // è¿‘Nä¸ªæœˆç°é‡‘æµ = è¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—å¹³è¡¡çº¿
                        periodResult.push(revenueSum - (periodMonths * balancePoint));
                    } else {
                        periodResult.push(null);
                    }
                }
                return periodResult;
            }

            result.quarterly = calculatePeriodCashFlowFromTarget(3, targetIndex);
            result.semiAnnual = calculatePeriodCashFlowFromTarget(6, targetIndex);
            result.ninthMonths = calculatePeriodCashFlowFromTarget(9, targetIndex); // æ·»åŠ 9ä¸ªæœˆè®¡ç®—
            result.annual = calculatePeriodCashFlowFromTarget(12, targetIndex);

            return result;
        }

        // åŠ¨æ€æ›´æ–°ç°é‡‘æµè¡¨æ ¼
        function updateCashFlowTable(storeData, indicator, targetIndex) {
            const storeName = storeData.length > 0 ? storeData[0]['é—¨åº—'] : currentStore;
            let balancePoint = 0;
            if (storeName === 'å¹³å®‰') {
                balancePoint = 215000;
            } else if (storeName === 'ä¾¨åŸ' || storeName === 'åŒçº') {
                balancePoint = 140000;
            }

            // è®¡ç®—åŸºäºç›®æ ‡æœˆä»½çš„ç°é‡‘æµ
            const cashFlow = calculateDynamicCashFlow(storeData, indicator.key, balancePoint, targetIndex);

            // æ›´æ–°è¡¨æ ¼
            const tbody = document.getElementById(`cashflow-tbody-${indicator.key}`);
            if (!tbody) return;

            // æ¸…ç©ºç°æœ‰å†…å®¹
            tbody.innerHTML = '';

            // è·å–ç›®æ ‡æœˆä»½ä¿¡æ¯
            const targetMonth = storeData[targetIndex];
            const monthLabel = `${targetMonth['å¹´ä»½']}-${targetMonth['æœˆä»½'].padStart(2, '0')}`;

            const periods = [
                { name: monthLabel, data: cashFlow.monthly, index: targetIndex },
                { name: `è¿‘3ä¸ªæœˆ(${monthLabel})`, data: cashFlow.quarterly, index: targetIndex },
                { name: `è¿‘6ä¸ªæœˆ(${monthLabel})`, data: cashFlow.semiAnnual, index: targetIndex },
                { name: `è¿‘9ä¸ªæœˆ(${monthLabel})`, data: cashFlow.ninthMonths, index: targetIndex }, // ä¿®å¤9ä¸ªæœˆæ•°æ®å¼•ç”¨
                { name: `è¿‘12ä¸ªæœˆ(${monthLabel})`, data: cashFlow.annual, index: targetIndex }
            ];

            periods.forEach(period => {
                if (period.data[period.index] !== null) {
                    const value = period.data[period.index];
                    const isPositive = value > 0;
                    const status = isPositive ? 'ç›ˆä½™' : 'äºæŸ';
                    // åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ˆè­¦ç¤ºï¼‰ï¼ŒäºæŸç”¨ç»¿è‰²
                    const statusColor = isPositive ? '#e74c3c' : '#27ae60';
                    const sign = isPositive ? '+' : '';

                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #e9ecef';
                    row.innerHTML = `
                        <td style="padding: 12px; font-weight: 500;">${period.name}</td>
                        <td style="padding: 12px; text-align: right; font-weight: 600; color: ${statusColor};">
                            ${sign}${formatValue(value / 10000, 1)}ä¸‡
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <span style="display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; background: ${statusColor}20; color: ${statusColor}; border: 1px solid ${statusColor}40;">
                                ${status}
                            </span>
                        </td>
                    `;
                    tbody.appendChild(row);
                }
            });

            // æ›´æ–°è¡¨æ ¼æ ‡é¢˜ï¼Œæ·»åŠ å½“å‰æ‚¬æµ®æœˆä»½æç¤º
            const tableTitle = document.querySelector(`#cashflow-table-${indicator.key} .chart-title`);
            if (tableTitle) {
                const originalTitle = indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµçŠ¶æ€è¡¨' : 'ç›ˆäºçŠ¶æ€è¡¨';
                tableTitle.innerHTML = `${originalTitle} <span style="color: #666; font-size: 12px; font-weight: normal;">(å½“å‰: ${monthLabel})</span>`;
            }
        }

      // æ˜¾ç¤ºæ‚¬æµ®ä¿¡æ¯æ¡†
        function showHoverInfo(event, storeData, dataIndex, indicator) {
            // ç§»é™¤å·²å­˜åœ¨çš„ä¿¡æ¯æ¡†
            hideHoverInfo();

            const hoverInfo = document.createElement('div');
            hoverInfo.className = 'hover-info';
            hoverInfo.id = 'hoverInfo';

            const monthData = storeData[dataIndex];
            const monthLabel = `${monthData['å¹´ä»½']}-${monthData['æœˆä»½'].padStart(2, '0')}`;

            // è®¡ç®—ç°é‡‘æµæ•°æ®
            const storeName = monthData['é—¨åº—'];
            let balancePoint = 0;
            if (storeName === 'å¹³å®‰') {
                balancePoint = 215000;
            } else if (storeName === 'ä¾¨åŸ' || storeName === 'åŒçº') {
                balancePoint = 140000;
            }

            if (indicator) {
                // è®¡ç®—åŸºäºç›®æ ‡æœˆä»½çš„ç°é‡‘æµæ•°æ®
                const cashFlow = calculateDynamicCashFlow(storeData, indicator.key, balancePoint, dataIndex);

                let content = `
                    <div class="month">ğŸ“… ${monthLabel}</div>
                `;

                // æ·»åŠ è¯¥æœˆçš„åŸºç¡€æ•°æ®
                const value = parseValue(monthData[indicator.key]);
                const formattedValue = formatValue(value / indicator.scale, 1);
                content += `
                    <div class="data">
                        <span class="label">${indicator.label}:</span>
                        <span class="value">${formattedValue}${indicator.unit}</span>
                    </div>
                `;

                // æ·»åŠ åˆ†å‰²çº¿
                content += `
                    <div style="margin: 4px 0; padding-top: 4px; border-top: 1px solid rgba(255,255,255,0.3);"></div>
                `;

                // æ˜¾ç¤ºå„ä¸ªå‘¨æœŸçš„ç°é‡‘æµæ•°æ®
                const periods = [
                    { name: 'å½“æœˆ', data: cashFlow.monthly, index: dataIndex },
                    { name: 'è¿‘3ä¸ªæœˆ', data: cashFlow.quarterly, index: dataIndex },
                    { name: 'è¿‘6ä¸ªæœˆ', data: cashFlow.semiAnnual, index: dataIndex },
                    { name: 'è¿‘9ä¸ªæœˆ', data: cashFlow.ninthMonths, index: dataIndex },
                    { name: 'è¿‘12ä¸ªæœˆ', data: cashFlow.annual, index: dataIndex }
                ];

                periods.forEach(period => {
                    if (period.data[period.index] !== null) {
                        const periodValue = period.data[period.index];
                        const isPositive = periodValue > 0;
                        const status = isPositive ? 'ç›ˆä½™' : 'äºæŸ';
                        const statusColor = isPositive ? '#e74c3c' : '#27ae60'; // çº¢è‰²è¡¨ç¤ºç›ˆä½™ï¼Œç»¿è‰²è¡¨ç¤ºäºæŸ
                        const sign = isPositive ? '+' : '';

                        content += `
                            <div class="data" style="font-size: 11px; margin: 1px 0;">
                                <span class="label" style="font-size: 10px;">${period.name}:</span>
                                <span class="value" style="color: ${statusColor}; font-size: 10px;">${sign}${formatValue(periodValue / 10000, 1)}ä¸‡</span>
                            </div>
                        `;
                    }
                });

                hoverInfo.innerHTML = content;
            } else {
                hoverInfo.innerHTML = `<div class="month">ğŸ“… ${monthLabel}</div>`;
            }

            // å®šä½ä¿¡æ¯æ¡†
            document.body.appendChild(hoverInfo);

            // è®¾ç½®ä½ç½®ï¼ˆè·Ÿéšé¼ æ ‡ï¼Œä½†æœ‰åç§»é¿å…é®æŒ¡ï¼‰
            const mouseX = event.clientX;
            const mouseY = event.clientY;
            const infoBox = hoverInfo.getBoundingClientRect();

            let left = mouseX + 15;
            let top = mouseY - infoBox.height / 2;

            // ç¡®ä¿ä¿¡æ¯æ¡†ä¸ä¼šè¶…å‡ºå±å¹•è¾¹ç•Œ
            if (left + infoBox.width > window.innerWidth) {
                left = mouseX - infoBox.width - 15;
            }
            if (top < 10) {
                top = 10;
            }
            if (top + infoBox.height > window.innerHeight) {
                top = window.innerHeight - infoBox.height - 10;
            }

            hoverInfo.style.left = left + 'px';
            hoverInfo.style.top = top + 'px';
        }

        // éšè—æ‚¬æµ®ä¿¡æ¯æ¡†
        function hideHoverInfo() {
            const hoverInfo = document.getElementById('hoverInfo');
            if (hoverInfo) {
                hoverInfo.remove();
            }
        }

        function calculateCashFlow(storeData, indicatorKey, balancePoint) {
            const result = {
                monthly: [],
                quarterly: [],
                semiAnnual: [],
                ninthMonths: [], // æ·»åŠ 9ä¸ªæœˆæ•°æ®æ•°ç»„
                annual: []
            };

            // æœˆåº¦ç°é‡‘æµï¼ˆè¥æ”¶ - æ”¶æ”¯å¹³è¡¡çº¿ï¼‰
            result.monthly = storeData.map((item, index) => {
                const value = parseValue(item[indicatorKey]);
                return value - balancePoint;
            });

            // è®¡ç®—ç´¯è®¡ç°é‡‘æµï¼ˆ3ä¸ªæœˆã€6ä¸ªæœˆã€12ä¸ªæœˆï¼‰
            function calculatePeriodCashFlow(periodMonths) {
                const periodResult = [];
                for (let i = 0; i < storeData.length; i++) {
                    if (i < periodMonths - 1) {
                        periodResult.push(null); // æ•°æ®ä¸è¶³
                    } else {
                        // è®¡ç®—è¿‘Nä¸ªæœˆçš„æ€»è¥æ”¶
                        let revenueSum = 0;
                        for (let j = i - periodMonths + 1; j <= i; j++) {
                            revenueSum += parseValue(storeData[j][indicatorKey]);
                        }
                        // è¿‘Nä¸ªæœˆç°é‡‘æµ = è¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—å¹³è¡¡çº¿
                        periodResult.push(revenueSum - (periodMonths * balancePoint));
                    }
                }
                return periodResult;
            }

            result.quarterly = calculatePeriodCashFlow(3);
            result.semiAnnual = calculatePeriodCashFlow(6);
            result.ninthMonths = calculatePeriodCashFlow(9); // æ·»åŠ 9ä¸ªæœˆè®¡ç®—
            result.annual = calculatePeriodCashFlow(12);

            return result;
        }

        // åˆ›å»ºç°é‡‘æµè¡¨æ ¼
        function createCashFlowTable(container, storeData, indicator, balancePoint) {
            const cashFlow = calculateCashFlow(storeData, indicator.key, balancePoint);
            const latestIndex = storeData.length - 1;

            // åˆ›å»ºæ•´åˆçš„ç°é‡‘æµå¡ç‰‡ï¼ˆåŒ…å«è¡¨æ ¼å’Œå›¾è¡¨ï¼‰
            const combinedContainer = document.createElement('div');
            combinedContainer.className = 'chart-container special-chart';
            combinedContainer.style.marginTop = '20px';

            const tableTitle = indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµè¡¨' : 'ç›ˆäºçŠ¶æ€è¡¨';
            const chartTitle = indicator.key === 'æ€»è¥æ”¶' ? 'æœˆåº¦ç°é‡‘æµç›ˆäºå›¾' : 'æœˆåº¦ç›ˆäºèµ°åŠ¿å›¾';
            const balanceType = indicator.key === 'æ€»è¥æ”¶' ? 'æ”¶æ”¯å¹³è¡¡çº¿' : 'ç›ˆäºå¹³è¡¡çº¿';

            // æ›´æ–°å‰¯æ ‡é¢˜ï¼Œè¯´æ˜æ­£ç¡®çš„ç®—æ³•
            const algorithmText = indicator.key === 'æ€»è¥æ”¶'
                ? 'ç®—æ³•ï¼šè¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—æ”¶æ”¯å¹³è¡¡çº¿'
                : 'ç®—æ³•ï¼šè¿‘Nä¸ªæœˆç¡®è®¤æ”¶å…¥ - NÃ—ç›ˆäºå¹³è¡¡çº¿';

            combinedContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${tableTitle} & ${chartTitle}</div>
                        <div class="chart-subtitle">${algorithmText}</div>
                    </div>
                </div>

                <!-- è¡¨æ ¼éƒ¨åˆ† -->
                <div style="padding: 20px; padding-bottom: 10px;">
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <thead style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <tr>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">æ—¶é—´æ®µ</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">${indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµé‡‘é¢' : 'ç›ˆäºé‡‘é¢'}</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">çŠ¶æ€</th>
                            </tr>
                        </thead>
                        <tbody id="cashflow-tbody-${indicator.key}">
                        </tbody>
                    </table>
                </div>

                <!-- å›¾è¡¨éƒ¨åˆ† -->
                <div style="padding: 0 20px 20px 20px;">
                    <div class="chart-wrapper" style="height: 300px;">
                        <canvas id="monthly-cashflow-chart-${indicator.key}"></canvas>
                    </div>
                </div>
            `;

            container.appendChild(combinedContainer);

            // å¡«å……è¡¨æ ¼æ•°æ®
            const tbody = document.getElementById(`cashflow-tbody-${indicator.key}`);

                const periods = [
                { name: 'å½“æœˆ', data: cashFlow.monthly, index: latestIndex },
                { name: 'è¿‘3ä¸ªæœˆ', data: cashFlow.quarterly, index: latestIndex },
                { name: 'è¿‘6ä¸ªæœˆ', data: cashFlow.semiAnnual, index: latestIndex },
                { name: 'è¿‘9ä¸ªæœˆ', data: cashFlow.ninthMonths, index: latestIndex }, // æ·»åŠ 9ä¸ªæœˆæ•°æ®
                { name: 'è¿‘12ä¸ªæœˆ', data: cashFlow.annual, index: latestIndex }
            ];

            periods.forEach(period => {
                if (period.data[period.index] !== null) {
                    const value = period.data[period.index];
                    const isPositive = value > 0;
                    const status = isPositive ? 'ç›ˆä½™' : 'äºæŸ';
                    // åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ˆè­¦ç¤ºï¼‰ï¼ŒäºæŸç”¨ç»¿è‰²
                    const statusColor = isPositive ? '#e74c3c' : '#27ae60';
                    const sign = isPositive ? '+' : '';

                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #e9ecef';
                    row.innerHTML = `
                        <td style="padding: 12px; font-weight: 500;">${period.name}</td>
                        <td style="padding: 12px; text-align: right; font-weight: 600; color: ${statusColor};">
                            ${sign}${formatValue(value / 10000, 1)}ä¸‡
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <span style="display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; background: ${statusColor}20; color: ${statusColor}; border: 1px solid ${statusColor}40;">
                                ${status}
                            </span>
                        </td>
                    `;
                    tbody.appendChild(row);
                }
            });

            // åœ¨åŒä¸€ä¸ªå¡ç‰‡ä¸­åˆ›å»ºæœˆåº¦ç›ˆäºå›¾è¡¨
            createMonthlyCashFlowChartInCard(combinedContainer, storeData, indicator, balancePoint);
        }

        // åœ¨æ•´åˆå¡ç‰‡ä¸­åˆ›å»ºæœˆåº¦ç›ˆäºå›¾è¡¨
        function createMonthlyCashFlowChartInCard(combinedContainer, storeData, indicator, balancePoint) {
            // è·å–æ‰€æœ‰æœˆä»½çš„æ•°æ®
            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);
            const monthlyCashFlow = storeData.map((item, index) => {
                const value = parseValue(item[indicator.key]);
                return value - balancePoint;
            });

            // å‡†å¤‡é¢œè‰²æ•°ç»„ - ç›ˆä½™ç”¨çº¢è‰²ï¼ŒäºæŸç”¨ç»¿è‰²
            const colors = monthlyCashFlow.map(value => value > 0 ? '#e74c3c' : '#27ae60');

            // è·å–canvaså…ƒç´ 
            const canvas = document.getElementById(`monthly-cashflow-chart-${indicator.key}`);
            const ctx = canvas.getContext('2d');

            // åˆ›å»ºå›¾è¡¨
            charts[`monthly-cashflow-chart-${indicator.key}`] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµ' : 'ç›ˆäº',
                        data: monthlyCashFlow,
                        backgroundColor: colors.map(color => color + '80'), // æ·»åŠ é€æ˜åº¦
                        borderColor: colors,
                        borderWidth: 2,
                        borderRadius: 5,
                        borderSkipped: false,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false // å®Œå…¨ç¦ç”¨å›¾ä¾‹
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const status = value > 0 ? 'ç›ˆä½™' : 'äºæŸ';
                                    return `${status}: Â¥${Math.abs(value / 10000).toFixed(1)}ä¸‡`;
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: function(value) {
                                return `${(value / 10000).toFixed(1)}ä¸‡`;
                            },
                            anchor: 'end',
                            align: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ç°é‡‘æµ (ä¸‡å…ƒ)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return (value / 10000).toFixed(1) + 'ä¸‡';
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            // æš‚æ—¶ç§»é™¤ç›ˆäºå¹³è¡¡çº¿ï¼Œä»¥è§£å†³å›¾ä¾‹é—®é¢˜
            // charts[`monthly-cashflow-chart-${indicator.key}`].data.datasets.push({
            //     label: 'ç›ˆäºå¹³è¡¡çº¿', // è®¾ç½®æ ‡ç­¾ï¼Œä½†ä¼šé€šè¿‡å¤šç§æ–¹å¼éšè—
            //     type: 'line', // æ˜ç¡®æŒ‡å®šä¸ºçº¿å‹
            //     data: new Array(monthlyCashFlow.length).fill(0),
            //     borderColor: '#f39c12',
            //     borderWidth: 2,
            //     borderDash: [8, 4],
            //     pointRadius: 0,
            //     fill: false,
            //     tension: 0,
            //     hidden: true, // å®Œå…¨éšè—æ•°æ®é›†
            //     hiddenInLegend: true, // ä¸åœ¨å›¾ä¾‹ä¸­æ˜¾ç¤º
            //     order: 1, // ç¡®ä¿çº¿åœ¨æŸ±å­åé¢æ¸²æŸ“
            //     skipNull: true, // è·³è¿‡ç©ºå€¼
            //     yAxisID: 'y', // ç¡®ä¿ä½¿ç”¨Yè½´
            //     borderWidth: 2,
            //     borderDash: [8, 4]
            // });

            // æ›´æ–°å›¾è¡¨
            charts[`monthly-cashflow-chart-${indicator.key}`].update();
        }

        // åˆ›å»ºæœˆåº¦ç›ˆäºå›¾è¡¨ï¼ˆæ˜¾ç¤ºåœ¨ç°é‡‘æµè¡¨æ ¼ä¸‹æ–¹ï¼‰
        function createMonthlyCashFlowChart(container, storeData, indicator, balancePoint) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.style.marginTop = '10px';
            chartContainer.style.background = '#f8f9fa';

            const chartTitle = indicator.key === 'æ€»è¥æ”¶' ? 'æœˆåº¦ç°é‡‘æµç›ˆäºå›¾' : 'æœˆåº¦ç°é‡‘æ”¶æ”¯ç›ˆäºå›¾';
            const algorithmText = 'æ˜¾ç¤ºæ¯ä¸ªæœˆç›¸å¯¹äºå¹³è¡¡çº¿çš„ç›ˆäºçŠ¶å†µ';

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${chartTitle}</div>
                        <div class="chart-subtitle">${algorithmText}</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="monthly-cashflow-chart-${indicator.key}"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            // è·å–æ‰€æœ‰æœˆä»½çš„æ•°æ®
            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);
            const monthlyCashFlow = storeData.map((item, index) => {
                const value = parseValue(item[indicator.key]);
                return value - balancePoint;
            });

            // å‡†å¤‡é¢œè‰²æ•°ç»„ - åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ŒäºæŸç”¨ç»¿è‰²
            const colors = monthlyCashFlow.map(value => value > 0 ? '#e74c3c' : '#27ae60');

            const ctx = document.getElementById(`monthly-cashflow-chart-${indicator.key}`).getContext('2d');

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: indicator.key === 'æ€»è¥æ”¶' ? 'æœˆåº¦ç°é‡‘æµ' : 'æœˆåº¦ç°é‡‘æ”¶æ”¯',
                        data: monthlyCashFlow,
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 2,
                            padding: 1,
                            formatter: function(value) {
                                const sign = value > 0 ? '+' : '';
                                return `${sign}${formatValue(value / 10000, 1)}`;
                            },
                            anchor: 'end',
                            align: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ç›ˆäºé‡‘é¢ï¼ˆä¸‡å…ƒï¼‰',
                                font: {
                                    size: 11
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatValue(value / 10000, 1) + 'ä¸‡';
                                },
                                font: {
                                    size: 9
                                }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            });
        }

        // åˆ›å»ºç°é‡‘æµå›¾è¡¨ï¼ˆæ›¿ä»£è¡¨æ ¼ï¼‰
        function createCashFlowChart(container, storeData, indicator, balancePoint) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.style.marginTop = '20px';
            chartContainer.style.background = '#f8f9fa';

            const tableTitle = indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµç›ˆäºçŠ¶æ€å›¾' : 'ç°é‡‘æ”¶æ”¯ç›ˆäºçŠ¶æ€å›¾';
            const algorithmText = indicator.key === 'æ€»è¥æ”¶'
                ? 'ç®—æ³•ï¼šè¿‘Nä¸ªæœˆæ€»è¥æ”¶ - NÃ—æ”¶æ”¯å¹³è¡¡çº¿'
                : 'ç®—æ³•ï¼šè¿‘Nä¸ªæœˆç¡®è®¤æ”¶å…¥ - NÃ—ç›ˆäºå¹³è¡¡çº¿';

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${tableTitle}</div>
                        <div class="chart-subtitle">${algorithmText}</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="cashflow-chart-${indicator.key}"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            const labels = ['å½“æœˆ', 'è¿‘3ä¸ªæœˆ', 'è¿‘6ä¸ªæœˆ', 'è¿‘9ä¸ªæœˆ', 'è¿‘12ä¸ªæœˆ'];
            const cashFlow = calculateCashFlow(storeData, indicator.key, balancePoint);
            const latestIndex = storeData.length - 1;

            // å‡†å¤‡æ•°æ®
            const chartData = [
                cashFlow.monthly[latestIndex],
                cashFlow.quarterly[latestIndex],
                cashFlow.semiAnnual[latestIndex],
                cashFlow.ninthMonths[latestIndex], // æ·»åŠ 9ä¸ªæœˆæ•°æ®
                cashFlow.annual[latestIndex]
            ].filter(value => value !== null);

            // å‡†å¤‡å¯¹åº”æ ‡ç­¾
            const validLabels = [];
            const validData = [];
            const colors = []; // æ ¹æ®ç›ˆäºçŠ¶æ€è®¾ç½®é¢œè‰²

            for (let i = 0; i < chartData.length; i++) {
                if (chartData[i] !== null) {
                    validLabels.push(labels[i]);
                    validData.push(chartData[i]);
                    // åè½¬é¢œè‰²ï¼šç›ˆä½™ç”¨çº¢è‰²ï¼ŒäºæŸç”¨ç»¿è‰²
                    colors.push(chartData[i] > 0 ? '#e74c3c' : '#27ae60');
                }
            }

            const ctx = document.getElementById(`cashflow-chart-${indicator.key}`).getContext('2d');

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: validLabels,
                    datasets: [{
                        label: indicator.key === 'æ€»è¥æ”¶' ? 'ç°é‡‘æµ' : 'ç°é‡‘æ”¶æ”¯',
                        data: validData,
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: true,
                            color: '#333',
                            font: {
                                size: 11,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                const sign = value > 0 ? '+' : '';
                                return `${sign}${formatValue(value / 10000, 1)}ä¸‡`;
                            },
                            anchor: 'end',
                            align: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'é‡‘é¢ï¼ˆä¸‡å…ƒï¼‰',
                                font: {
                                    size: 12
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatValue(value / 10000, 1) + 'ä¸‡';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // åˆ›å»ºæ–°å®¢åˆ†æå›¾è¡¨
        function createAClassCombinedChart(container, storeData) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container special-chart';

            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">æ–°å®¢åˆ†æ</div>
                        <div class="chart-subtitle">ç¾å›¢ç‚¹è¯„ã€è·¯è¿‡ã€è€å¸¦æ–°ã€å…¶ä»–æ¸ é“å¯¹æ¯”</div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="aClassCombinedChart"></canvas>
                </div>
            `;

            container.appendChild(chartContainer);

            const labels = storeData.map(item => `${item['å¹´ä»½']}-${item['æœˆä»½'].padStart(2, '0')}`);

            // å‚è€ƒåŸºç¡€æŒ‡æ ‡çš„å¤„ç†æ–¹å¼ï¼Œæ¯ä¸ªæ•°æ®é›†ç‹¬ç«‹å¤„ç†
            const datasets = [];

            aClassIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                const borderColor = indicator.color;
                const backgroundColor = indicator.color + '20';

                datasets.push({
                    label: indicator.label,
                    data: values,
                    borderColor: borderColor,
                    backgroundColor: backgroundColor,
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: borderColor,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    tension: 0.2,
                    fill: false
                });
            });

            const ctx = document.getElementById('aClassCombinedChart').getContext('2d');

            charts.aClassCombinedChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true, // å¯ç”¨å›¾ä¾‹ï¼Œè®©ç”¨æˆ·å¯ä»¥æ§åˆ¶æ˜¾ç¤º/éšè—
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                },
                                boxWidth: 12,
                                padding: 15,
                                // è‡ªå®šä¹‰å›¾ä¾‹ç”Ÿæˆï¼Œåªæ˜¾ç¤ºä¸»è¦æ•°æ®é›†
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        // åªè¿”å›å‰aClassIndicators.lengthä¸ªæ•°æ®é›†ï¼ˆä¸»è¦æ•°æ®é›†ï¼‰
                                        return data.datasets.slice(0, aClassIndicators.length).map((dataset, i) => ({
                                            text: dataset.label,
                                            fillStyle: dataset.borderColor,
                                            strokeStyle: dataset.borderColor,
                                            lineWidth: dataset.borderWidth,
                                            pointStyle: 'rectRounded',
                                            hidden: !chart.isDatasetVisible(i),
                                            datasetIndex: i
                                        }));
                                    }
                                    return [];
                                }
                            },
                            // è‡ªå®šä¹‰ç‚¹å‡»å¤„ç†
                            onClick: function(e, legendItem, legend) {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);

                                // åˆ‡æ¢ä¸»æ•°æ®é›†çš„æ˜¾ç¤ºçŠ¶æ€
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;

                                // åŒæ—¶åˆ‡æ¢ç›¸å…³çš„å‚è€ƒçº¿æ•°æ®é›†
                                for (let i = aClassIndicators.length; i < chart.data.datasets.length; i++) {
                                    const refMeta = chart.getDatasetMeta(i);
                                    const refDataset = chart.data.datasets[i];
                                    // å‚è€ƒçº¿è·Ÿéšå¯¹åº”çš„ä¸»æ•°æ®é›†çš„çŠ¶æ€
                                    if (refDataset.datasetIndexKey === 'reference' && refDataset.mainDatasetIndex === index) {
                                        refMeta.hidden = meta.hidden;
                                    }
                                }

                                chart.update();
                            }
                        },
                        tooltip: {
                            filter: function(tooltipItem) {
                                // åªæ˜¾ç¤ºä¸»è¦çš„æ•°æ®é›†ï¼Œéšè—æ‰€æœ‰å‚è€ƒçº¿
                                return tooltipItem.datasetIndex < aClassIndicators.length;
                            },
                            callbacks: {
                                label: function(context) {
                                    const datasetLabel = context.dataset.label || '';
                                    if (datasetLabel === 'æ–°å®¢æ€»è®¡') {
                                        const total = aClassIndicators.reduce((sum, indicator) => {
                                            return sum + parseValue(storeData[context.dataIndex][indicator.key]);
                                        }, 0);
                                        return `æ–°å®¢æ€»è®¡: ${formatValue(total, 1)}äºº`;
                                    } else {
                                        return `${datasetLabel}: ${formatValue(context.parsed.y, 1)}äºº`;
                                    }
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // åªæ˜¾ç¤ºä¸»è¦æ•°æ®é›†çš„æ ‡ç­¾ï¼Œéšè—æ‰€æœ‰å‚è€ƒçº¿æ ‡ç­¾
                                return context.datasetIndex < aClassIndicators.length;
                            },
                            color: function(context) {
                                return context.dataset.borderColor;
                            },
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderColor: function(context) {
                                return context.dataset.borderColor;
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 2,
                            formatter: function(value) {
                                return formatValue(value, 1) + 'äºº';
                            },
                            align: function(context) {
                                const chart = context.chart;
                                const chartArea = chart.chartArea;
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                const y = dataset.data[dataIndex];
                                const scaledY = chart.scales.y.getPixelForValue(y);

                                // å¦‚æœå½“å‰ç‚¹åœ¨å›¾è¡¨ä¸ŠåŠéƒ¨åˆ†ï¼Œæ ‡ç­¾æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                                if (scaledY < chartArea.top + 50) {
                                    return 'bottom';
                                }

                                // æ£€æŸ¥ç›¸é‚»æ•°æ®ç‚¹çš„å€¼ï¼Œé¿å…é‡å 
                                const prevY = dataIndex > 0 ? dataset.data[dataIndex - 1] : null;
                                const nextY = dataIndex < dataset.data.length - 1 ? dataset.data[dataIndex + 1] : null;

                                // å¦‚æœä¸ç›¸é‚»ç‚¹å€¼æ¥è¿‘ï¼Œäº¤æ›¿æ˜¾ç¤ºä½ç½®
                                if (prevY && Math.abs(y - prevY) < (chart.scales.y.max - chart.scales.y.min) * 0.08) {
                                    return dataIndex % 2 === 0 ? 'top' : 'bottom';
                                }

                                return 'top';
                            },
                            offset: 8
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'äººæ•°',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + 'äºº';
                                },
                                font: {
                                    size: 11
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'å˜åŒ–é€Ÿåº¦ (%)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                display: false
                            },
                            // è®¾ç½®åˆç†çš„èŒƒå›´
                            min: -100,
                            max: 100
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });

            // ä¸ºæ¯ä¸ªæ•°æ®é›†æ·»åŠ æ–°çš„åˆ†ææŒ‡æ ‡
            aClassIndicators.forEach((indicator, index) => {
                const values = storeData.map(item => parseValue(item[indicator.key]));
                setTimeout(() => {
                    addAnalysisIndicators(charts.aClassCombinedChart, values, 1, 'äºº', storeData[0]['é—¨åº—'], index);
                }, 100);
            });
        }


        
      // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            init();

            // è®¾ç½®å¯¼èˆªäº¤äº’äº‹ä»¶
            setupNavigationInteraction();
        });

        // è®¾ç½®å¯¼èˆªäº¤äº’åŠŸèƒ½
        function setupNavigationInteraction() {
            const trigger = document.getElementById('chartNavigationTrigger');
            const navigation = document.getElementById('chartNavigation');
            let isNavVisible = false;
            let hideTimeout;

            // é¼ æ ‡è¿›å…¥è§¦å‘æŒ‰é’®æ—¶æ˜¾ç¤ºå¯¼èˆª
            trigger.addEventListener('mouseenter', function() {
                clearTimeout(hideTimeout);
                showNavigation();
            });

            // é¼ æ ‡è¿›å…¥å¯¼èˆªé¢æ¿æ—¶ä¿æŒæ˜¾ç¤º
            navigation.addEventListener('mouseenter', function() {
                clearTimeout(hideTimeout);
            });

            // é¼ æ ‡ç¦»å¼€å¯¼èˆªé¢æ¿æ—¶å»¶è¿Ÿéšè—
            navigation.addEventListener('mouseleave', function() {
                hideTimeout = setTimeout(() => {
                    hideNavigation();
                }, 300);
            });

            // é¼ æ ‡ç¦»å¼€è§¦å‘æŒ‰é’®æ—¶å»¶è¿Ÿéšè—
            trigger.addEventListener('mouseleave', function() {
                hideTimeout = setTimeout(() => {
                    hideNavigation();
                }, 300);
            });

            // ç‚¹å‡»è§¦å‘æŒ‰é’®åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
            trigger.addEventListener('click', function() {
                if (isNavVisible) {
                    hideNavigation();
                } else {
                    showNavigation();
                }
            });

            // ç‚¹å‡»å¯¼èˆªé¢æ¿å¤–çš„åŒºåŸŸéšè—å¯¼èˆª
            document.addEventListener('click', function(e) {
                if (!trigger.contains(e.target) && !navigation.contains(e.target)) {
                    hideNavigation();
                }
            });

            // æ˜¾ç¤ºå¯¼èˆª
            function showNavigation() {
                navigation.classList.add('show');
                trigger.classList.add('active');
                isNavVisible = true;
            }

            // éšè—å¯¼èˆª
            function hideNavigation() {
                navigation.classList.remove('show');
                trigger.classList.remove('active');
                isNavVisible = false;
            }
        }
    </script>
</body>
</html>